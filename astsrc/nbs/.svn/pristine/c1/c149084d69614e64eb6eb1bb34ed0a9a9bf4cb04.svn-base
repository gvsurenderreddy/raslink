diff -uNr xmms-1.2.10/configure xmms-1.2.10-nbs/configure
--- xmms-1.2.10/configure	2004-02-23 15:44:32.000000000 -0600
+++ xmms-1.2.10-nbs/configure	2004-04-16 08:43:24.000000000 -0500
@@ -468,7 +468,7 @@
 #endif"
 
 ac_subdirs_all="$ac_subdirs_all libxmms"
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM AWK SET_MAKE am__leading_dot ac_prefix_program CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CCAS CCASFLAGS LN_S ECHO RANLIB ac_ct_RANLIB CPP EGREP LIBTOOL GLIB_CONFIG GLIB_CFLAGS GLIB_LIBS GTK_CONFIG GTK_CFLAGS GTK_LIBS XMMS_PATH SM_LIBS LIBICONV LTLIBICONV VM_LIBS PTHREAD_LIBS OPENGL_LIBS HAVE_OPENGL_TRUE HAVE_OPENGL_FALSE Z_LIBS ESD_CONFIG ESD_CFLAGS ESD_LIBS HAVE_ESD_TRUE HAVE_ESD_FALSE LIBMIKMOD_CONFIG LIBMIKMOD_CFLAGS LIBMIKMOD_LIBS LIBMIKMOD_LDADD HAVE_MIKMOD_TRUE HAVE_MIKMOD_FALSE OGG_CFLAGS OGG_LIBS VORBIS_CFLAGS VORBIS_LIBS VORBISFILE_LIBS VORBISENC_LIBS HAVE_OGGVORBIS_TRUE HAVE_OGGVORBIS_FALSE MKINSTALLDIRS USE_NLS MSGFMT GMSGFMT XGETTEXT MSGMERGE ALLOCA GLIBC21 INTLBISON BUILD_INCLUDED_LIBINTL USE_INCLUDED_LIBINTL CATOBJEXT DATADIRNAME INSTOBJEXT GENCAT INTLOBJS INTL_LIBTOOL_SUFFIX_PREFIX INTLLIBS LIBINTL LTLIBINTL POSUB localedir EFFECT_PLUGINS GENERAL_PLUGINS INPUT_PLUGINS OUTPUT_PLUGINS VISUALIZATION_PLUGINS USE_SIMD_TRUE USE_SIMD_FALSE USE_IPV6_TRUE USE_IPV6_FALSE USE_IPV6 HAVE_OSS_TRUE HAVE_OSS_FALSE ALSA_CFLAGS ALSA_LIBS HAVE_ALSA_TRUE HAVE_ALSA_FALSE POSIX_LIBS HAVE_CDROM_TRUE HAVE_CDROM_FALSE HAVE_LINUX_JOYSTICK_TRUE HAVE_LINUX_JOYSTICK_FALSE ARCH_DEFINES ARCH_X86_TRUE ARCH_X86_FALSE USE_X86ASM_TRUE USE_X86ASM_FALSE HAVE_SOLARIS_TRUE HAVE_SOLARIS_FALSE HAVE_SUN_TRUE HAVE_SUN_FALSE plugindir INPUT_PLUGIN_DIR OUTPUT_PLUGIN_DIR EFFECT_PLUGIN_DIR GENERAL_PLUGIN_DIR VISUALIZATION_PLUGIN_DIR pluginsubs XMMS_DEFINES PLUGIN_LDFLAGS subdirs xmmsdir LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM AWK SET_MAKE am__leading_dot ac_prefix_program CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CCAS CCASFLAGS LN_S ECHO RANLIB ac_ct_RANLIB CPP EGREP LIBTOOL GLIB_CONFIG GLIB_CFLAGS GLIB_LIBS GTK_CONFIG GTK_CFLAGS GTK_LIBS XMMS_PATH SM_LIBS LIBICONV LTLIBICONV VM_LIBS PTHREAD_LIBS OPENGL_LIBS HAVE_OPENGL_TRUE HAVE_OPENGL_FALSE Z_LIBS ESD_CONFIG ESD_CFLAGS ESD_LIBS HAVE_ESD_TRUE HAVE_ESD_FALSE LIBMIKMOD_CONFIG LIBMIKMOD_CFLAGS LIBMIKMOD_LIBS LIBMIKMOD_LDADD HAVE_MIKMOD_TRUE HAVE_MIKMOD_FALSE OGG_CFLAGS OGG_LIBS VORBIS_CFLAGS VORBIS_LIBS VORBISFILE_LIBS VORBISENC_LIBS HAVE_OGGVORBIS_TRUE HAVE_OGGVORBIS_FALSE MKINSTALLDIRS USE_NLS MSGFMT GMSGFMT XGETTEXT MSGMERGE ALLOCA GLIBC21 INTLBISON BUILD_INCLUDED_LIBINTL USE_INCLUDED_LIBINTL CATOBJEXT DATADIRNAME INSTOBJEXT GENCAT INTLOBJS INTL_LIBTOOL_SUFFIX_PREFIX INTLLIBS LIBINTL LTLIBINTL POSUB localedir EFFECT_PLUGINS GENERAL_PLUGINS INPUT_PLUGINS OUTPUT_PLUGINS VISUALIZATION_PLUGINS USE_SIMD_TRUE USE_SIMD_FALSE USE_IPV6_TRUE USE_IPV6_FALSE USE_IPV6 HAVE_OSS_TRUE HAVE_OSS_FALSE HAVE_NBS_TRUE HAVE_NBS_FALSE ALSA_CFLAGS ALSA_LIBS HAVE_ALSA_TRUE HAVE_ALSA_FALSE POSIX_LIBS HAVE_CDROM_TRUE HAVE_CDROM_FALSE HAVE_LINUX_JOYSTICK_TRUE HAVE_LINUX_JOYSTICK_FALSE ARCH_DEFINES ARCH_X86_TRUE ARCH_X86_FALSE USE_X86ASM_TRUE USE_X86ASM_FALSE HAVE_SOLARIS_TRUE HAVE_SOLARIS_FALSE HAVE_SUN_TRUE HAVE_SUN_FALSE plugindir INPUT_PLUGIN_DIR OUTPUT_PLUGIN_DIR EFFECT_PLUGIN_DIR GENERAL_PLUGIN_DIR VISUALIZATION_PLUGIN_DIR pluginsubs XMMS_DEFINES PLUGIN_LDFLAGS subdirs xmmsdir LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -1035,6 +1035,7 @@
   --enable-simd           build with x86 SIMD(3DNow!/MMX) instructions support (default=no)
   --enable-ipv6           enable IPv6 support (default=no)
   --disable-oss           disable the OSS output plugin
+  --disable-nbs           disable the NBS output plugin
   --disable-alsatest      Do not try to compile and run a test Alsa program
 
 Optional Packages:
@@ -15497,6 +15498,14 @@
   have_oss=yes
 fi;
 
+# Check whether --enable-nbs or --disable-nbs was given.
+if test "${enable_nbs+set}" = set; then
+  enableval="$enable_nbs"
+  have_nbs=$enableval
+else
+  have_nbs=yes
+fi;
+
 if test "$have_oss" = "auto"; then
     echo "$as_me:$LINENO: checking for OSS include dir" >&5
 echo $ECHO_N "checking for OSS include dir... $ECHO_C" >&6
@@ -15835,6 +15844,191 @@
   HAVE_OSS_FALSE=
 fi
 
+if test "$have_nbs" = "auto"; then
+    echo "$as_me:$LINENO: checking for NBS include dir" >&5
+echo $ECHO_N "checking for NBS include dir... $ECHO_C" >&6
+    NBS_CFLAGS=""
+    if test -f "/usr/include/nbs.h"
+    then
+        NBS_CFLAGS="-I/usr/include"
+    fi
+    if test -n "$NBS_CFLAGS"
+    then
+        echo "$as_me:$LINENO: result: $NBS_CFLAGS" >&5
+echo "${ECHO_T}$NBS_CFLAGS" >&6
+    else
+        echo "$as_me:$LINENO: result: not found" >&5
+echo "${ECHO_T}not found" >&6
+    fi
+    CPPFLAGS_save=$CPPFLAGS
+    CPPFLAGS="$CPPFLAGS $NBS_CFLAGS"
+
+for ac_header in nbs.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+    CPPFLAGS=$CPPFLAGS_save
+
+    if test "${ac_cv_header_nbs_h}" = "yes"; then
+        have_nbs=yes
+    fi
+fi
+
+if test "$have_nbs" = "yes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_NBS 1
+_ACEOF
+
+else
+    have_nbs=no
+fi
+
+
+if test "$have_nbs" = "yes"; then
+  HAVE_NBS_TRUE=
+  HAVE_NBS_FALSE='#'
+else
+  HAVE_NBS_TRUE='#'
+  HAVE_NBS_FALSE=
+fi
 
 
 LIBS_save=$LIBS
@@ -19201,7 +19395,7 @@
 
 
 
-                                                                                                                                                                                                                                                                                                                                                                        ac_config_files="$ac_config_files Makefile xmms.1 wmxmms.1 xmms.spec xmms-config xmms/Makefile xmms/defskin/Makefile Output/Makefile Output/OSS/Makefile Output/esd/Makefile Output/disk_writer/Makefile Output/solaris/Makefile Output/sun/Makefile Output/alsa/Makefile Input/Makefile Input/wav/Makefile Input/mpg123/Makefile Input/mikmod/Makefile Input/cdaudio/Makefile Input/tonegen/Makefile Input/vorbis/Makefile Effect/Makefile Effect/voice/Makefile Effect/echo_plugin/Makefile Effect/stereo_plugin/Makefile General/Makefile General/ir/Makefile General/joystick/Makefile General/song_change/Makefile Visualization/Makefile Visualization/blur_scope/Makefile Visualization/sanalyzer/Makefile Visualization/opengl_spectrum/Makefile wmxmms/Makefile po/Makefile.in intl/Makefile"
+                                                                                                                                                                                                                                                                                                                                                                        ac_config_files="$ac_config_files Makefile xmms.1 wmxmms.1 xmms.spec xmms-config xmms/Makefile xmms/defskin/Makefile Output/Makefile Output/OSS/Makefile Output/esd/Makefile Output/disk_writer/Makefile Output/solaris/Makefile Output/nbs/Makefile Output/sun/Makefile Output/alsa/Makefile Input/Makefile Input/wav/Makefile Input/mpg123/Makefile Input/mikmod/Makefile Input/cdaudio/Makefile Input/tonegen/Makefile Input/vorbis/Makefile Effect/Makefile Effect/voice/Makefile Effect/echo_plugin/Makefile Effect/stereo_plugin/Makefile General/Makefile General/ir/Makefile General/joystick/Makefile General/song_change/Makefile Visualization/Makefile Visualization/blur_scope/Makefile Visualization/sanalyzer/Makefile Visualization/opengl_spectrum/Makefile wmxmms/Makefile po/Makefile.in intl/Makefile"
           ac_config_commands="$ac_config_commands default"
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -19357,6 +19551,13 @@
 Usually this means the macro was only invoked conditionally." >&2;}
    { (exit 1); exit 1; }; }
 fi
+if test -z "${HAVE_NBS_TRUE}" && test -z "${HAVE_NBS_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"HAVE_NBS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"HAVE_NBS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
 if test -z "${HAVE_ALSA_TRUE}" && test -z "${HAVE_ALSA_FALSE}"; then
   { { echo "$as_me:$LINENO: error: conditional \"HAVE_ALSA\" was never defined.
 Usually this means the macro was only invoked conditionally." >&5
@@ -19868,6 +20069,7 @@
   "Output/esd/Makefile" ) CONFIG_FILES="$CONFIG_FILES Output/esd/Makefile" ;;
   "Output/disk_writer/Makefile" ) CONFIG_FILES="$CONFIG_FILES Output/disk_writer/Makefile" ;;
   "Output/solaris/Makefile" ) CONFIG_FILES="$CONFIG_FILES Output/solaris/Makefile" ;;
+  "Output/nbs/Makefile" ) CONFIG_FILES="$CONFIG_FILES Output/nbs/Makefile" ;;
   "Output/sun/Makefile" ) CONFIG_FILES="$CONFIG_FILES Output/sun/Makefile" ;;
   "Output/alsa/Makefile" ) CONFIG_FILES="$CONFIG_FILES Output/alsa/Makefile" ;;
   "Input/Makefile" ) CONFIG_FILES="$CONFIG_FILES Input/Makefile" ;;
@@ -20104,6 +20306,8 @@
 s,@USE_IPV6@,$USE_IPV6,;t t
 s,@HAVE_OSS_TRUE@,$HAVE_OSS_TRUE,;t t
 s,@HAVE_OSS_FALSE@,$HAVE_OSS_FALSE,;t t
+s,@HAVE_NBS_TRUE@,$HAVE_NBS_TRUE,;t t
+s,@HAVE_NBS_FALSE@,$HAVE_NBS_FALSE,;t t
 s,@ALSA_CFLAGS@,$ALSA_CFLAGS,;t t
 s,@ALSA_LIBS@,$ALSA_LIBS,;t t
 s,@HAVE_ALSA_TRUE@,$HAVE_ALSA_TRUE,;t t
@@ -21019,6 +21223,7 @@
 fi
 
 echo "  Build OSS plugin:           $have_oss"
+echo "  Build NBS plugin:           $have_nbs"
 echo "  Build esd plugin:           $have_esd"
 echo "  Build Solaris plugin:       $have_solaris"
 echo "  Build BSD Sun plugin:       $have_sun"
diff -uNr xmms-1.2.10/configure.in xmms-1.2.10-nbs/configure.in
--- xmms-1.2.10/configure.in	2004-02-23 15:40:44.000000000 -0600
+++ xmms-1.2.10-nbs/configure.in	2004-04-16 08:43:24.000000000 -0500
@@ -324,6 +324,9 @@
 
 AC_ARG_ENABLE(oss, [  --disable-oss           disable the OSS output plugin],
 	      have_oss=$enableval, have_oss=yes)
+
+AC_ARG_ENABLE(nbs, [  --disable-nbs           disable the NBS output plugin],
+	      have_nbs=$enableval, have_nbs=yes)
          
 if test "$have_oss" = "auto"; then
     AC_MSG_CHECKING(for OSS include dir)
@@ -366,6 +369,36 @@
 fi
 AM_CONDITIONAL(HAVE_OSS, test "$have_oss" = "yes")
     
+if test "$have_nbs" = "auto"; then
+    AC_MSG_CHECKING(for NBS include dir)
+    NBS_CFLAGS=""
+    if test -f "/usr/include/nbs.h"
+    then
+          NBS_CFLAGS="-I/usr/include"
+    fi
+    if test -n "$NBS_CFLAGS"
+    then
+        AC_MSG_RESULT([$NBS_CFLAGS])
+    else
+        AC_MSG_RESULT([not found])
+    fi
+    CPPFLAGS_save=$CPPFLAGS
+    CPPFLAGS="$CPPFLAGS $NBS_CFLAGS"
+    AC_CHECK_HEADERS(nbs.h)
+    CPPFLAGS=$CPPFLAGS_save
+
+    if test "${ac_cv_header_nbs_h}" = "yes"; then
+        have_nbs=yes
+    fi
+fi
+
+if test "$have_nbs" = "yes"; then
+    AC_DEFINE(HAVE_NBS, 1, [Define if the NBS output plugin should be built])
+else
+    have_nbs=no
+fi
+AM_CONDITIONAL(HAVE_NBS, test "$have_nbs" = "yes")
+    
 
 LIBS_save=$LIBS
 CFLAGS_save=$CFLAGS
@@ -578,6 +611,7 @@
 Output/esd/Makefile
 Output/disk_writer/Makefile
 Output/solaris/Makefile
+Output/nbs/Makefile
 Output/sun/Makefile
 Output/alsa/Makefile
 Input/Makefile
@@ -612,6 +646,7 @@
 fi
 
 echo "  Build OSS plugin:           $have_oss"
+echo "  Build NBS plugin:           $have_nbs"
 echo "  Build esd plugin:           $have_esd"
 echo "  Build Solaris plugin:       $have_solaris"
 echo "  Build BSD Sun plugin:       $have_sun"
diff -uNr xmms-1.2.10/Output/Makefile.am xmms-1.2.10-nbs/Output/Makefile.am
--- xmms-1.2.10/Output/Makefile.am	2003-05-19 16:22:06.000000000 -0500
+++ xmms-1.2.10-nbs/Output/Makefile.am	2004-04-16 08:43:24.000000000 -0500
@@ -1,2 +1,2 @@
-ALL_PLUGINS = OSS esd disk_writer solaris sun alsa
+ALL_PLUGINS = OSS esd disk_writer solaris sun alsa nbs
 SUBDIRS = @OUTPUT_PLUGINS@
diff -uNr xmms-1.2.10/Output/nbs/about.c xmms-1.2.10-nbs/Output/nbs/about.c
--- xmms-1.2.10/Output/nbs/about.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.10-nbs/Output/nbs/about.c	2004-04-16 08:43:24.000000000 -0500
@@ -0,0 +1,49 @@
+/*  XMMS - Cross-platform multimedia player
+ *  Copyright (C) 1998-2000  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmms/i18n.h"
+#include "nbs.h"
+#include "libxmms/util.h"
+
+void nbs_about(void)
+{
+	static GtkWidget *dialog;
+
+	if (dialog != NULL)
+		return;
+	
+	dialog = xmms_show_message(
+		_("About NBS Driver"),
+		_("XMMS NBS Driver\n\n "
+		  "This program is free software; you can redistribute it and/or modify\n"
+		  "it under the terms of the GNU General Public License as published by\n"
+		  "the Free Software Foundation; either version 2 of the License, or\n"
+		  "(at your option) any later version.\n"
+		  "\n"
+		  "This program is distributed in the hope that it will be useful,\n"
+		  "but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
+		  "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
+		  "GNU General Public License for more details.\n"
+		  "\n"
+		  "You should have received a copy of the GNU General Public License\n"
+		  "along with this program; if not, write to the Free Software\n"
+		  "Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n"
+		  "USA."), _("Ok"), FALSE, NULL, NULL);
+	gtk_signal_connect(GTK_OBJECT(dialog), "destroy",
+			   GTK_SIGNAL_FUNC(gtk_widget_destroyed),
+			   &dialog);
+}
diff -uNr xmms-1.2.10/Output/nbs/audio.c xmms-1.2.10-nbs/Output/nbs/audio.c
--- xmms-1.2.10/Output/nbs/audio.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.10-nbs/Output/nbs/audio.c	2004-04-16 08:43:24.000000000 -0500
@@ -0,0 +1,756 @@
+/*  XMMS - Crnbs-platform multimedia player
+ *  Copyright (C) 1998-2001  Peter Alm, Mikael Alm, Olle Hallnas,
+ *                           Thomas Nilsson and 4Front Technologies
+ *  Copyright (C) 1999-2001  Haavard Kvaalen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmmsnbs.h"
+#include "libxmms/util.h"
+#include <errno.h>
+#include <nbs.h>
+
+#define NFRAGS		32
+
+static char *buffer;
+static gboolean going, prebuffer, paused, unpause, do_pause, remove_prebuffer;
+static gint device_buffer_used, buffer_size, prebuffer_size, blk_size = 4096;
+static gint rd_index = 0, wr_index = 0;
+static gint output_time_offset = 0;
+static guint64 written = 0, output_bytes = 0;
+static gint flush;
+static gint fragsize, device_buffer_size;
+static gchar *device_name;
+static pthread_t buffer_thread;
+static gboolean realtime, select_works;
+static int realchannels;
+static NBS *nbs;
+
+static int (*nbs_convert_func)(void **data, int length);
+
+struct format_info {
+	union {
+		AFormat xmms;
+		int nbs;
+	} format;
+	int frequency;
+	int channels;
+	int bps;
+};
+
+
+/*
+ * The format of the data from the input plugin
+ * This will never change during a song. 
+ */
+struct format_info input;
+
+/*
+ * The format we get from the effect plugin.
+ * This will be different from input if the effect plugin does
+ * some kind of format conversion.
+ */
+struct format_info effect;
+
+/*
+ * The format of the data we actually send to the soundcard.
+ * This might be different from effect if we need to resample or do
+ * some other format conversion.
+ */
+struct format_info output;
+
+
+#if 0
+static void nbs_calc_device_buffer_used(void)
+{
+	audio_buf_info buf_info;
+	if(paused)
+		device_buffer_used = 0;
+	else if (!ioctl(fd, SNDCTL_DSP_GETOSPACE, &buf_info))
+		device_buffer_used = (buf_info.fragstotal * buf_info.fragsize) - buf_info.bytes;
+}
+#endif
+
+
+static gint nbs_downsample(gpointer ob, guint length, guint speed, guint espeed);
+
+static int nbs_calc_bitrate(int nbs_fmt, int rate, int channels)
+{
+	int bitrate = rate * channels;
+
+	if (nbs_fmt == NBS_FMT_U16_BE || nbs_fmt == NBS_FMT_U16_LE ||
+	    nbs_fmt == NBS_FMT_S16_BE || nbs_fmt == NBS_FMT_S16_LE)
+		bitrate *= 2;
+
+	return bitrate;
+}
+
+static int nbs_get_format(AFormat fmt)
+{
+	int format = 0;
+
+	switch (fmt)
+	{
+		case FMT_U8:
+			format = NBS_FMT_U8;
+			break;
+		case FMT_S8:
+			format = NBS_FMT_S8;
+			break;
+		case FMT_U16_LE:
+			format = NBS_FMT_U16_LE;
+			break;
+		case FMT_U16_BE:
+			format = NBS_FMT_U16_BE;
+			break;
+		case FMT_U16_NE:
+#ifdef WORDS_BIGENDIAN
+			format = NBS_FMT_U16_BE;
+#else
+			format = NBS_FMT_U16_LE;
+#endif
+			break;
+		case FMT_S16_LE:
+			format = NBS_FMT_S16_LE;
+			break;
+		case FMT_S16_BE:
+			format = NBS_FMT_S16_BE;
+			break;
+		case FMT_S16_NE:
+#ifdef WORDS_BIGENDIAN
+			format = NBS_FMT_S16_BE;
+#else
+			format = NBS_FMT_S16_LE;
+#endif
+			break;
+	}
+
+	return format;
+}
+
+static void nbs_setup_format(AFormat fmt, int rate, int nch)
+{
+	effect.format.xmms = fmt;
+	effect.frequency = rate;
+	effect.channels = nch;
+	effect.bps = nbs_calc_bitrate(nbs_get_format(fmt), rate, nch);
+
+	/* Output is fixed format for NBS */
+	output.format.nbs = NBS_FORMAT;
+	output.frequency = NBS_BITRATE;
+	output.channels = NBS_CHANNELS;
+
+
+	nbs_set_audio_params();
+
+	output.bps = nbs_calc_bitrate(output.format.nbs, output.frequency,
+				      output.channels);
+}
+	
+
+gint nbs_get_written_time(void)
+{
+	if (!going)
+		return 0;
+	return (written * 1000) / effect.bps;
+}
+
+gint nbs_get_output_time(void)
+{
+	guint64 bytes;
+
+	if (!nbs || !going)
+		return 0;
+
+	bytes = output_bytes < device_buffer_used ?
+		0 : output_bytes - device_buffer_used;
+
+	return output_time_offset + ((bytes * 1000) / output.bps);
+}
+
+static int nbs_used(void)
+{
+	if (realtime)
+		return 0;
+	else
+	{
+		if (wr_index >= rd_index)
+			return wr_index - rd_index;
+		return buffer_size - (rd_index - wr_index);
+	}
+}
+
+gint nbs_playing(void)
+{
+	if(!going)
+		return 0;
+	if (!nbs_used() && (device_buffer_used - (3 * blk_size)) <= 0)
+		return FALSE;
+
+	return TRUE;
+}
+
+gint nbs_free(void)
+{
+	if (!realtime)
+	{
+		if (remove_prebuffer && prebuffer)
+		{
+			prebuffer = FALSE;
+			remove_prebuffer = FALSE;
+		}
+		if (prebuffer)
+			remove_prebuffer = TRUE;
+
+		if (rd_index > wr_index)
+			return (rd_index - wr_index) - device_buffer_size - 1;
+		return (buffer_size - (wr_index - rd_index)) - device_buffer_size - 1;
+	}
+	else
+		if (paused)
+			return 0;
+		else
+			return 1000000;
+}
+
+static inline ssize_t write_all(NBS *nbs, const void *buf, size_t count)
+{
+	ssize_t done = 0;
+	do {
+		ssize_t n = nbs_write(nbs, buf, (count - done) / (NBS_CHANNELS * 2));
+		if (n == -1)
+		{
+			if (errno == EINTR)
+				continue;
+			else
+				break;
+		}
+		done += n * (NBS_CHANNELS * 2);
+	} while (count > done);
+
+	return done;
+}
+
+static void make_stereo(gpointer dataout, gpointer datain, int length)
+{
+	/* Signededness doesn't matter for this operation */
+	unsigned short *ins = datain, *outs = dataout;
+	unsigned char *inc = datain, *outc = dataout;
+	int x;
+	switch (output.format.nbs)
+	{
+		case NBS_FMT_S16_BE:
+		case NBS_FMT_S16_LE:
+		case NBS_FMT_U16_BE:
+		case NBS_FMT_U16_LE:
+			for (x=0;x<length;x++)
+				outs[x] = ins[x >> 1];
+			break;
+		case NBS_FMT_S8:
+		case NBS_FMT_U8:
+			for (x=0;x<length<<1;x++)
+				outc[x] = inc[x >> 1];
+			break;
+	}
+}
+
+static void nbs_write_audio(gpointer data, int length)
+{
+	AFormat new_format;
+	int new_frequency, new_channels;
+	EffectPlugin *ep;
+	gpointer data2;
+	
+	
+	new_format = input.format.xmms;
+	new_frequency = input.frequency;
+	new_channels = input.channels;
+	
+	ep = get_current_effect_plugin();
+	if(effects_enabled() && ep && ep->query_format)
+	{
+		ep->query_format(&new_format,&new_frequency,&new_channels);
+	}
+	
+	if (new_format != effect.format.xmms ||
+	    new_frequency != effect.frequency ||
+	    new_channels != effect.channels)
+	{
+		output_time_offset += (output_bytes * 1000) / output.bps;
+		output_bytes = 0;
+		nbs_setup_format(new_format, new_frequency, new_channels);
+	}
+	if (effects_enabled() && ep && ep->mod_samples)
+		length = ep->mod_samples(&data, length,
+					 input.format.xmms,
+					 input.frequency,
+					 input.channels);
+	if (realtime)
+	{
+		while (nbs_freespace(nbs) < (length / (NBS_CHANNELS * 2)))
+		{
+			printf("Stuck sleeping waiting for %d...\n", length);
+			xmms_usleep(10000);
+		}
+	}
+
+	if (nbs_convert_func != NULL)
+		length = nbs_convert_func(&data, length);
+
+	if (effect.channels < realchannels) {
+		/* Gotta double for stereo-only cards */
+		data2 = alloca(length * 2);
+		if (!data2) {
+			static int warnedalready;
+			if (!warnedalready) {
+				g_warning("Unable to allocate memory for re-channelization: %s\n", strerror(errno));
+				warnedalready++;
+			}
+		} else {
+			make_stereo(data2, data, length);
+			data = data2;
+			length *= 2;
+		}
+	}
+
+	if (effect.frequency == output.frequency) {
+		if (nbs) {
+			output_bytes += nbs_write(nbs, data, length / (NBS_CHANNELS * 2)) * (NBS_CHANNELS * 2);
+		} else
+			g_warning("Trying to write with no NBS client\n");
+	} else {
+		output_bytes += nbs_downsample(data, length,
+					       effect.frequency,
+					       output.frequency);
+	}						   
+}
+
+static void swap_endian(guint16 *data, int length)
+{
+	int i;
+	for (i = 0; i < length; i += 2, data++)
+		*data = GUINT16_SWAP_LE_BE(*data);
+}
+
+#define NOT_NATIVE_ENDIAN ((IS_BIG_ENDIAN &&				\
+			   (output.format.nbs == NBS_FMT_S16_LE ||		\
+			    output.format.nbs == NBS_FMT_U16_LE)) ||	\
+			  (!IS_BIG_ENDIAN &&				\
+			   (output.format.nbs == NBS_FMT_S16_BE ||		\
+			    output.format.nbs == NBS_FMT_U16_BE)))
+
+
+#define RESAMPLE_STEREO(sample_type)				\
+do {								\
+	const gint shift = sizeof (sample_type);		\
+        gint i, in_samples, out_samples, x, delta;		\
+	sample_type *inptr = (sample_type *)ob, *outptr;	\
+	guint nlen = (((length >> shift) * espeed) / speed);	\
+	if (nlen == 0)						\
+		break;						\
+	nlen <<= shift;						\
+	if (NOT_NATIVE_ENDIAN)					\
+		swap_endian(ob, length);			\
+	if(nlen > nbuffer_size)					\
+	{							\
+		nbuffer = g_realloc(nbuffer, nlen);		\
+		nbuffer_size = nlen;				\
+	}							\
+	outptr = (sample_type *)nbuffer;			\
+	in_samples = length >> shift;				\
+        out_samples = nlen >> shift;				\
+	delta = (in_samples << 12) / out_samples;		\
+	for (x = 0, i = 0; i < out_samples; i++)		\
+	{							\
+		gint x1, frac;					\
+		x1 = (x >> 12) << 12;				\
+		frac = x - x1;					\
+		*outptr++ =					\
+			(sample_type)				\
+			((inptr[(x1 >> 12) << 1] *		\
+			  ((1<<12) - frac) +			\
+			  inptr[((x1 >> 12) + 1) << 1] *	\
+			  frac) >> 12);				\
+		*outptr++ =					\
+			(sample_type)				\
+			((inptr[((x1 >> 12) << 1) + 1] *	\
+			  ((1<<12) - frac) +			\
+			  inptr[(((x1 >> 12) + 1) << 1) + 1] *	\
+			  frac) >> 12);				\
+		x += delta;					\
+	}							\
+	if (NOT_NATIVE_ENDIAN)					\
+		swap_endian(nbuffer, nlen);			\
+	w = write_all(nbs, nbuffer, nlen);			\
+} while (0)
+
+
+#define RESAMPLE_MONO(sample_type)				\
+do {								\
+	const gint shift = sizeof (sample_type) - 1;		\
+        gint i, x, delta, in_samples, out_samples;		\
+	sample_type *inptr = (sample_type *)ob, *outptr;	\
+	guint nlen = (((length >> shift) * espeed) / speed);	\
+	if (nlen == 0)						\
+		break;						\
+	nlen <<= shift;						\
+	if (NOT_NATIVE_ENDIAN)					\
+		swap_endian(ob, length);			\
+	if(nlen > nbuffer_size)					\
+	{							\
+		nbuffer = g_realloc(nbuffer, nlen);		\
+		nbuffer_size = nlen;				\
+	}							\
+	outptr = (sample_type *)nbuffer;			\
+	in_samples = length >> shift;				\
+        out_samples = nlen >> shift;				\
+	delta = ((length >> shift) << 12) / out_samples;	\
+	for (x = 0, i = 0; i < out_samples; i++)		\
+	{							\
+		gint x1, frac;					\
+		x1 = (x >> 12) << 12;				\
+		frac = x - x1;					\
+		*outptr++ =					\
+			(sample_type)				\
+			((inptr[x1 >> 12] * ((1<<12) - frac) +	\
+			  inptr[(x1 >> 12) + 1] * frac) >> 12);	\
+		x += delta;					\
+	}							\
+	if (NOT_NATIVE_ENDIAN)					\
+		swap_endian(nbuffer, nlen);			\
+	w = write_all(nbs, nbuffer, nlen);			\
+} while (0)
+
+
+static gint nbs_downsample(gpointer ob, guint length, guint speed, guint espeed)
+{
+	guint w = 0;
+	static gpointer nbuffer = NULL;
+	static gint nbuffer_size = 0;
+
+	switch (output.format.nbs)
+	{
+		case NBS_FMT_S16_BE:
+		case NBS_FMT_S16_LE:
+			if (output.channels == 2)
+				RESAMPLE_STEREO(gint16);
+			else
+				RESAMPLE_MONO(gint16);
+			break;
+		case NBS_FMT_U16_BE:
+		case NBS_FMT_U16_LE:
+			if (output.channels == 2)
+				RESAMPLE_STEREO(guint16);
+			else
+				RESAMPLE_MONO(guint16);
+			break;
+		case NBS_FMT_S8:
+			if (output.channels == 2)
+				RESAMPLE_STEREO(gint8);
+			else
+				RESAMPLE_MONO(gint8);
+			break;
+		case NBS_FMT_U8:
+			if (output.channels == 2)
+				RESAMPLE_STEREO(guint8);
+			else
+				RESAMPLE_MONO(guint8);
+			break;
+	}
+	return w;
+}
+
+void nbs_xwrite(gpointer ptr, int length)
+{
+	int cnt, off = 0;
+
+	if (!realtime)
+	{
+		remove_prebuffer = FALSE;
+
+		written += length;
+		while (length > 0)
+		{
+			cnt = MIN(length, buffer_size - wr_index);
+			memcpy(buffer + wr_index, (char *)ptr + off, cnt);
+			wr_index = (wr_index + cnt) % buffer_size;
+			length -= cnt;
+			off += cnt;
+		}
+	}
+	else
+	{
+		if (paused)
+			return;
+		nbs_write_audio(ptr, length);
+		written += length;
+	}
+}
+
+void nbs_close(void)
+{
+	if (!going)
+		return;
+	going = 0;
+	if (!realtime)
+		pthread_join(buffer_thread, NULL);
+	else
+	{
+#if 0
+		ioctl(fd, SNDCTL_DSP_RESET, 0);
+		close(fd);
+#endif
+		if (nbs) {
+			nbs_delstream(nbs);
+			nbs = NULL;
+		}		
+	}
+	g_free(device_name);
+	nbs_get_convert_buffer(0);
+	wr_index = 0;
+	rd_index = 0;
+}
+
+void nbs_flush(gint time)
+{
+	if (!realtime)
+	{
+		flush = time;
+		while (flush != -1)
+			xmms_usleep(10000);
+	}
+	else
+	{
+#if 0
+		/* No concept of flushing */
+		ioctl(fd, SNDCTL_DSP_RESET, 0);
+		close(fd);
+		fd = open(device_name, O_WRONLY);
+		nbs_set_audio_params();
+		output_time_offset = time;
+		written = ((guint64)time * input.bps) / 1000;
+		output_bytes = 0;
+#endif		
+	}
+}
+
+void nbs_pause(short p)
+{
+	if (!realtime)
+	{
+		if (p == TRUE)
+			do_pause = TRUE;
+		else
+			unpause = TRUE;
+	}
+	else
+		paused = p;
+
+}
+
+void *nbs_loop(void *arg)
+{
+	gint length, cnt;
+	fd_set set;
+	struct timeval tv;
+
+	while (going)
+	{
+		if (nbs_used() > prebuffer_size)
+			prebuffer = FALSE;
+		if (nbs_used() > 0 && !paused && !prebuffer)
+		{
+			tv.tv_sec = 0;
+			tv.tv_usec = 10000;
+			FD_ZERO(&set);
+			FD_SET(nbs_fd(nbs), &set);
+			if(!select_works || (select(nbs_fd(nbs) + 1, NULL, &set, NULL, &tv) > 0))
+			{
+				length = MIN(blk_size, nbs_used());
+				while (length > 0)
+				{
+					cnt = MIN(length,buffer_size-rd_index);
+					nbs_write_audio(buffer + rd_index, cnt);
+					rd_index=(rd_index+cnt)%buffer_size;
+					length-=cnt;				
+				}
+			}
+		}
+		else
+			xmms_usleep(10000);
+		if (do_pause && !paused)
+		{
+			do_pause = FALSE;
+			paused = TRUE;
+#if 0
+			/* NBS has no flush */
+			/*
+			 * We lose some data here that is sent to the
+			 * soundcard, but not yet played.  I don't
+			 * think this is worth fixing.
+			 */
+			ioctl(fd, SNDCTL_DSP_RESET, 0);
+#endif			
+		}
+		else if (unpause && paused)
+		{
+			/* NBS has nothing really to have to do to unpause */
+			unpause = FALSE;
+#if 0
+			close(fd);
+			fd = open(device_name, O_WRONLY);
+			nbs_set_audio_params();
+#endif			
+			paused = FALSE;
+		}
+
+		if (flush != -1)
+		{
+			/*
+			 * This close and open is a work around of a
+			 * bug that exists in some drivers which cause
+			 * the driver to get fucked up by a reset
+			 */
+
+#if 0
+			ioctl(fd, SNDCTL_DSP_RESET, 0);
+			close(fd);
+			fd = open(device_name, O_WRONLY);
+			nbs_set_audio_params();
+#endif		
+			output_time_offset = flush;
+			written = ((guint64)flush * input.bps) / 1000;
+			rd_index = wr_index = output_bytes = 0;
+			flush = -1;
+			prebuffer = TRUE;
+		}
+
+	}
+
+#if 0
+	/* NBS has no reset */
+	ioctl(fd, SNDCTL_DSP_RESET, 0);
+#endif
+	nbs_delstream(nbs);
+	nbs = NULL;	
+	g_free(buffer);
+	pthread_exit(NULL);
+}
+
+void nbs_set_audio_params(void)
+{
+	int frag, stereo, ret;
+	struct timeval tv;
+	fd_set set;
+
+#if 0
+	/* None of this works with nbs */
+	ioctl(fd, SNDCTL_DSP_RESET, 0);
+	frag = (NFRAGS << 16) | fragsize;
+	ioctl(fd, SNDCTL_DSP_SETFRAGMENT, &frag);
+	ioctl(fd, SNDCTL_DSP_SETFMT, &output.format.nbs);
+	if (ioctl(fd, SNDCTL_DSP_SETFMT, &output.format.nbs) == -1)
+		g_warning("SNDCTL_DSP_SETFMT ioctl failed: %s",
+			  strerror(errno));
+#endif
+	/* Don't store in output.channels, but in another variable */
+	realchannels = 2;
+
+	nbs_convert_func =
+		nbs_get_convert_func(output.format.nbs,
+				     nbs_get_format(effect.format.xmms));
+
+	/*
+	 * Stupid hack to find out if the driver support selects, some
+	 * drivers won't work properly without a select and some won't
+	 * work with a select :/
+	 */
+	
+	tv.tv_sec = 0;
+	tv.tv_usec = 50000;
+	FD_ZERO(&set);
+	FD_SET(nbs_fd(nbs), &set);
+	ret = select(nbs_fd(nbs) + 1, NULL, &set, NULL, &tv);
+	if (ret > 0)
+		select_works = TRUE;
+	else
+		select_works = FALSE;
+}
+
+gint nbs_open(AFormat fmt, gint rate, gint nch)
+{
+	char host[256] = "dunno";
+	if (nbs_cfg.use_alt_audio_device && nbs_cfg.alt_audio_device)
+		device_name = g_strdup(nbs_cfg.alt_audio_device);
+	else
+	{
+		if (nbs_cfg.audio_device > 0)
+			device_name = g_strdup_printf("%s%d", DEV_DSP, nbs_cfg.audio_device);
+		else
+			device_name = g_strdup(DEV_DSP);
+	}
+	gethostname(host, sizeof(host));
+	nbs =  nbs_newstream("xmms", host, NBS_FLAG_OVERRIDE);
+	if (nbs == NULL)
+	{
+		g_warning("nbs_open(): Failed to open NBS stream: %s", strerror(errno));
+		g_free(device_name);
+		return 0;
+	}
+	nbs_setblocking(nbs, 1);
+	nbs_setdebug(nbs, 1);
+	nbs_setblocksize(nbs, blk_size);
+	if (nbs_connect(nbs))
+	{
+		g_warning("nbs_open(): Failed to connect NBS stream: %s", strerror(errno));
+		nbs_delstream(nbs);
+		g_free(device_name);
+		return 0;
+	}
+	
+	input.format.xmms = fmt;
+	input.frequency = rate;
+	input.channels = nch;
+	input.bps = nbs_calc_bitrate(nbs_get_format(fmt), rate, nch);
+
+	nbs_setup_format(fmt, rate, nch);
+	
+	realtime = xmms_check_realtime_priority();
+	
+	if(!realtime)
+	{
+		buffer_size = (nbs_cfg.buffer_size * input.bps) / 1000;
+		if (buffer_size < 8192)
+			buffer_size = 8192;
+		prebuffer_size = (buffer_size * nbs_cfg.prebuffer) / 100;
+		if (buffer_size - prebuffer_size < 4096)
+			prebuffer_size = buffer_size - 4096;
+
+		buffer_size += device_buffer_size;
+		buffer = g_malloc0(buffer_size);
+	}
+	flush = -1;
+	prebuffer = TRUE;
+	wr_index = rd_index = output_time_offset = written = output_bytes = 0;
+	paused = FALSE;
+	do_pause = FALSE;
+	unpause = FALSE;
+	remove_prebuffer = FALSE;
+
+	going = 1;
+	if (!realtime)
+		pthread_create(&buffer_thread, NULL, nbs_loop, NULL);
+	return 1;
+}
diff -uNr xmms-1.2.10/Output/nbs/configure.c xmms-1.2.10-nbs/Output/nbs/configure.c
--- xmms-1.2.10/Output/nbs/configure.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.10-nbs/Output/nbs/configure.c	2004-04-16 08:43:24.000000000 -0500
@@ -0,0 +1,323 @@
+/*  XMMS - Cross-platform multimedia player
+ *  Copyright (C) 1998-2001  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *  Copyright (C) 1999-2001  Håvard Kvålen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmms/i18n.h"
+#include "nbs.h"
+
+#if 0
+/* One day I'll be configurable... */
+static GtkWidget *configure_win = NULL;
+static GtkWidget *mixer_usemaster_check, *buffer_size_spin, *buffer_pre_spin;
+static GtkWidget *adevice_use_alt_check, *audio_alt_device_entry;
+static GtkWidget *mdevice_use_alt_check, *mixer_alt_device_entry;
+static gint audio_device, mixer_device;
+
+static void configure_win_ok_cb(GtkWidget * w, gpointer data)
+{
+	ConfigFile *cfgfile;
+
+	oss_cfg.audio_device = audio_device;
+	oss_cfg.mixer_device = mixer_device;
+	oss_cfg.buffer_size =
+		gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(buffer_size_spin));
+	oss_cfg.prebuffer =
+		gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(buffer_pre_spin));
+	oss_cfg.use_master =
+		gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(mixer_usemaster_check));
+	oss_cfg.use_alt_audio_device =
+		gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(adevice_use_alt_check));
+	oss_cfg.use_alt_mixer_device =
+		gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(mdevice_use_alt_check));
+	g_free(oss_cfg.alt_audio_device);
+	oss_cfg.alt_audio_device =
+		gtk_editable_get_chars(GTK_EDITABLE(audio_alt_device_entry), 0, -1);
+	g_strstrip(oss_cfg.alt_audio_device);
+	g_free(oss_cfg.alt_mixer_device);
+	oss_cfg.alt_mixer_device =
+		gtk_editable_get_chars(GTK_EDITABLE(mixer_alt_device_entry), 0, -1);
+	g_strstrip(oss_cfg.alt_mixer_device);
+
+	if (oss_cfg.use_alt_audio_device)
+		/* do a minimum of sanity checking */
+		if (oss_cfg.alt_audio_device[0] != '/') 
+			oss_cfg.use_alt_audio_device = FALSE;
+	if (oss_cfg.use_alt_mixer_device)
+		if (oss_cfg.alt_mixer_device[0] != '/') 
+			oss_cfg.use_alt_mixer_device = FALSE;
+	
+	cfgfile = xmms_cfg_open_default_file();
+
+	xmms_cfg_write_int(cfgfile, "OSS", "audio_device", oss_cfg.audio_device);
+	xmms_cfg_write_int(cfgfile, "OSS", "mixer_device", oss_cfg.mixer_device);
+	xmms_cfg_write_int(cfgfile, "OSS", "buffer_size", oss_cfg.buffer_size);
+	xmms_cfg_write_int(cfgfile, "OSS", "prebuffer", oss_cfg.prebuffer);
+	xmms_cfg_write_boolean(cfgfile,"OSS","use_master",oss_cfg.use_master);
+	xmms_cfg_write_boolean(cfgfile, "OSS", "use_alt_audio_device", oss_cfg.use_alt_audio_device);
+	xmms_cfg_write_string(cfgfile, "OSS", "alt_audio_device", oss_cfg.alt_audio_device);
+	xmms_cfg_write_boolean(cfgfile, "OSS", "use_alt_mixer_device", oss_cfg.use_alt_mixer_device);
+	xmms_cfg_write_string(cfgfile, "OSS", "alt_mixer_device", oss_cfg.alt_mixer_device);
+	xmms_cfg_write_default_file(cfgfile);
+	xmms_cfg_free(cfgfile);
+
+	gtk_widget_destroy(configure_win);
+}
+
+static void configure_win_audio_dev_cb(GtkWidget * widget, gint device)
+{
+	audio_device = device;
+}
+
+static void configure_win_mixer_dev_cb(GtkWidget * widget, gint device)
+{
+	mixer_device = device;
+}
+
+static void audio_device_toggled(GtkToggleButton * widget, gpointer data)
+{
+	gboolean use_alt_audio_device = gtk_toggle_button_get_active(widget);
+	gtk_widget_set_sensitive(GTK_WIDGET(data), !use_alt_audio_device);
+	gtk_widget_set_sensitive(audio_alt_device_entry, use_alt_audio_device);
+}
+
+static void mixer_device_toggled(GtkToggleButton * widget, gpointer data)
+{
+	gboolean use_alt_device = gtk_toggle_button_get_active(widget);
+	gtk_widget_set_sensitive(GTK_WIDGET(data), !use_alt_device);
+	gtk_widget_set_sensitive(mixer_alt_device_entry, use_alt_device);
+}
+
+static void scan_devices(gchar * type, GtkWidget * option_menu, GtkSignalFunc sigfunc)
+{
+	GtkWidget *menu, *item;
+	FILE *file;
+	gchar buffer[256], *temp, *tmp2;
+	gboolean found = FALSE;
+	gint index = 0;
+
+	menu = gtk_menu_new();
+
+	if ((file = fopen("/dev/sndstat", "r")))
+	{
+		while (fgets(buffer, 255, file))
+		{
+			if (found && buffer[0] == '\n')
+				break;
+			if (buffer[strlen(buffer) - 1] == '\n')
+				buffer[strlen(buffer) - 1] = '\0';
+			if (found)
+			{
+				if (index == 0)
+				{
+					tmp2 = strchr(buffer, ':');
+					if (tmp2)
+					{
+						tmp2++;
+						while (*tmp2 == ' ')
+							tmp2++;
+					}
+					else
+						tmp2 = buffer;
+					temp = g_strdup_printf(_("Default (%s)"), tmp2);
+					item = gtk_menu_item_new_with_label(temp);
+					g_free(temp);
+				}
+				else
+					item = gtk_menu_item_new_with_label(buffer);
+				gtk_signal_connect(GTK_OBJECT(item), "activate", sigfunc, (gpointer) index++);
+				gtk_widget_show(item);
+				gtk_menu_append(GTK_MENU(menu), item);
+			}
+			if (!strcasecmp(buffer, type))
+				found = 1;
+
+		}
+		fclose(file);
+	}
+	else
+	{
+		item = gtk_menu_item_new_with_label(_("Default"));
+		gtk_signal_connect(GTK_OBJECT(item), "activate", sigfunc, (gpointer) 0);
+		gtk_widget_show(item);
+		gtk_menu_append(GTK_MENU(menu), item);
+	}
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(option_menu), menu);
+}
+
+void oss_configure(void)
+{
+	GtkWidget *vbox, *notebook;
+	GtkWidget *dev_vbox, *adevice_frame, *adevice_box, *adevice;
+	GtkWidget *mdevice_frame, *mdevice_box, *mdevice;
+	GtkWidget *buffer_frame, *buffer_vbox, *buffer_table;
+	GtkWidget *buffer_size_box, *buffer_size_label;
+	GtkObject *buffer_size_adj, *buffer_pre_adj;
+	GtkWidget *buffer_pre_box, *buffer_pre_label;
+	GtkWidget *audio_alt_box, *mixer_alt_box;
+	GtkWidget *bbox, *ok, *cancel;
+	GtkWidget *mixer_table, *mixer_frame;
+	
+	if (configure_win)
+	{
+		gdk_window_raise(configure_win->window);
+		return;
+	}
+
+	configure_win = gtk_window_new(GTK_WINDOW_DIALOG);
+	gtk_signal_connect(GTK_OBJECT(configure_win), "destroy", GTK_SIGNAL_FUNC(gtk_widget_destroyed), &configure_win);
+	gtk_window_set_title(GTK_WINDOW(configure_win), _("OSS Driver configuration"));
+	gtk_window_set_policy(GTK_WINDOW(configure_win), FALSE, FALSE, FALSE);
+	gtk_window_set_position(GTK_WINDOW(configure_win), GTK_WIN_POS_MOUSE);
+	gtk_container_border_width(GTK_CONTAINER(configure_win), 10);
+	
+	vbox = gtk_vbox_new(FALSE, 10);
+	gtk_container_add(GTK_CONTAINER(configure_win), vbox);
+	
+	notebook = gtk_notebook_new();
+	gtk_box_pack_start(GTK_BOX(vbox), notebook, TRUE, TRUE, 0);
+	
+	dev_vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(dev_vbox), 5);
+
+	adevice_frame = gtk_frame_new(_("Audio device:"));
+	gtk_box_pack_start(GTK_BOX(dev_vbox), adevice_frame, FALSE, FALSE, 0);
+	
+	adevice_box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(adevice_box), 5);
+	gtk_container_add(GTK_CONTAINER(adevice_frame), adevice_box);
+
+	adevice = gtk_option_menu_new();
+	gtk_box_pack_start(GTK_BOX(adevice_box), adevice, TRUE, TRUE, 0);
+#if defined(HAVE_NEWPCM)
+	scan_devices("Installed devices:",adevice, configure_win_audio_dev_cb);
+#else
+	scan_devices("Audio devices:", adevice, configure_win_audio_dev_cb);
+#endif
+	audio_device = oss_cfg.audio_device;
+	gtk_option_menu_set_history(GTK_OPTION_MENU(adevice), oss_cfg.audio_device);
+	audio_alt_box = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start_defaults(GTK_BOX(adevice_box), audio_alt_box);
+	adevice_use_alt_check = gtk_check_button_new_with_label(_("Use alternate device:"));
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(adevice_use_alt_check), oss_cfg.use_alt_audio_device);
+	gtk_signal_connect(GTK_OBJECT(adevice_use_alt_check), "toggled", audio_device_toggled, adevice);
+	gtk_box_pack_start(GTK_BOX(audio_alt_box), adevice_use_alt_check, FALSE, FALSE, 0);
+	audio_alt_device_entry = gtk_entry_new();
+	if (oss_cfg.alt_audio_device != NULL)
+		gtk_entry_set_text(GTK_ENTRY(audio_alt_device_entry), oss_cfg.alt_audio_device);
+	else
+		gtk_entry_set_text(GTK_ENTRY(audio_alt_device_entry), DEV_DSP);
+	gtk_box_pack_start_defaults(GTK_BOX(audio_alt_box), audio_alt_device_entry);
+
+	if (oss_cfg.use_alt_audio_device)
+		gtk_widget_set_sensitive(adevice, FALSE);
+	else
+		gtk_widget_set_sensitive(audio_alt_device_entry, FALSE);
+
+	mdevice_frame = gtk_frame_new(_("Mixer device:"));
+	gtk_box_pack_start(GTK_BOX(dev_vbox), mdevice_frame, FALSE, FALSE, 0);
+	
+	mdevice_box = gtk_vbox_new(FALSE, 0);
+	gtk_container_set_border_width(GTK_CONTAINER(mdevice_box), 5);
+	gtk_container_add(GTK_CONTAINER(mdevice_frame), mdevice_box);
+
+	mdevice = gtk_option_menu_new();
+	gtk_box_pack_start(GTK_BOX(mdevice_box), mdevice, TRUE, TRUE, 0);
+#if defined(HAVE_NEWPCM)
+	scan_devices("Installed devices:",mdevice, configure_win_mixer_dev_cb);
+#else
+	scan_devices("Mixers:", mdevice, configure_win_mixer_dev_cb);
+#endif
+	mixer_device = oss_cfg.mixer_device;
+	gtk_option_menu_set_history(GTK_OPTION_MENU(mdevice), oss_cfg.mixer_device);
+	mixer_alt_box = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start_defaults(GTK_BOX(mdevice_box), mixer_alt_box);
+	mdevice_use_alt_check = gtk_check_button_new_with_label(_("Use alternate device:"));
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(mdevice_use_alt_check), oss_cfg.use_alt_mixer_device);
+	gtk_signal_connect(GTK_OBJECT(mdevice_use_alt_check), "toggled", mixer_device_toggled, mdevice);
+	gtk_box_pack_start(GTK_BOX(mixer_alt_box), mdevice_use_alt_check, FALSE, FALSE, 0);
+	mixer_alt_device_entry = gtk_entry_new();
+	if (oss_cfg.alt_mixer_device != NULL)
+		gtk_entry_set_text(GTK_ENTRY(mixer_alt_device_entry), oss_cfg.alt_mixer_device);
+	else
+		gtk_entry_set_text(GTK_ENTRY(mixer_alt_device_entry), DEV_MIXER);
+	gtk_box_pack_start_defaults(GTK_BOX(mixer_alt_box), mixer_alt_device_entry);
+
+	if (oss_cfg.use_alt_mixer_device)
+		gtk_widget_set_sensitive(mdevice, FALSE);
+	else
+		gtk_widget_set_sensitive(mixer_alt_device_entry, FALSE);
+
+	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), dev_vbox, gtk_label_new(_("Devices")));
+
+	buffer_frame = gtk_frame_new(_("Buffering:"));
+	gtk_container_set_border_width(GTK_CONTAINER(buffer_frame), 5);
+
+	buffer_vbox = gtk_vbox_new(FALSE, 0);
+	gtk_container_add(GTK_CONTAINER(buffer_frame), buffer_vbox);
+
+	buffer_table = gtk_table_new(2, 1, TRUE);
+	gtk_container_set_border_width(GTK_CONTAINER(buffer_table), 5);
+	gtk_box_pack_start(GTK_BOX(buffer_vbox), buffer_table, FALSE, FALSE, 0);
+
+	buffer_size_box = gtk_hbox_new(FALSE, 5);
+	gtk_table_attach_defaults(GTK_TABLE(buffer_table), buffer_size_box, 0, 1, 0, 1);
+	buffer_size_label = gtk_label_new(_("Buffer size (ms):"));
+	gtk_box_pack_start(GTK_BOX(buffer_size_box), buffer_size_label, FALSE, FALSE, 0);
+	buffer_size_adj = gtk_adjustment_new(oss_cfg.buffer_size, 200, 10000, 100, 100, 100);
+	buffer_size_spin = gtk_spin_button_new(GTK_ADJUSTMENT(buffer_size_adj), 8, 0);
+	gtk_widget_set_usize(buffer_size_spin, 60, -1);
+	gtk_box_pack_start(GTK_BOX(buffer_size_box), buffer_size_spin, FALSE, FALSE, 0);
+
+	buffer_pre_box = gtk_hbox_new(FALSE, 5);
+	gtk_table_attach_defaults(GTK_TABLE(buffer_table), buffer_pre_box, 1, 2, 0, 1);
+	buffer_pre_label = gtk_label_new(_("Pre-buffer (percent):"));
+	gtk_box_pack_start(GTK_BOX(buffer_pre_box), buffer_pre_label, FALSE, FALSE, 0);
+	buffer_pre_adj = gtk_adjustment_new(oss_cfg.prebuffer, 0, 90, 1, 1, 1);
+	buffer_pre_spin = gtk_spin_button_new(GTK_ADJUSTMENT(buffer_pre_adj), 1, 0);
+	gtk_widget_set_usize(buffer_pre_spin, 60, -1);
+	gtk_box_pack_start(GTK_BOX(buffer_pre_box), buffer_pre_spin, FALSE, FALSE, 0);
+
+	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), buffer_frame, gtk_label_new(_("Buffering")));
+	mixer_frame = gtk_frame_new(_("Mixer Settings:"));
+	gtk_container_set_border_width(GTK_CONTAINER(mixer_frame), 5);
+	mixer_table = gtk_table_new(3, 2, TRUE);
+	gtk_container_add(GTK_CONTAINER(mixer_frame), mixer_table);
+	gtk_container_set_border_width(GTK_CONTAINER(mixer_table), 5);
+	mixer_usemaster_check=gtk_check_button_new_with_label(_("Volume controls Master not PCM"));
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(mixer_usemaster_check),oss_cfg.use_master);
+	gtk_table_attach_defaults(GTK_TABLE(mixer_table), mixer_usemaster_check, 0, 1, 0, 1);
+	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), mixer_frame, gtk_label_new(_("Mixer")));
+
+	bbox = gtk_hbutton_box_new();
+	gtk_button_box_set_layout(GTK_BUTTON_BOX(bbox), GTK_BUTTONBOX_END);
+	gtk_button_box_set_spacing(GTK_BUTTON_BOX(bbox), 5);
+	gtk_box_pack_start(GTK_BOX(vbox), bbox, FALSE, FALSE, 0);
+
+	ok = gtk_button_new_with_label(_("Ok"));
+	gtk_signal_connect(GTK_OBJECT(ok), "clicked", GTK_SIGNAL_FUNC(configure_win_ok_cb), NULL);
+	GTK_WIDGET_SET_FLAGS(ok, GTK_CAN_DEFAULT);
+	gtk_box_pack_start(GTK_BOX(bbox), ok, TRUE, TRUE, 0);
+	gtk_widget_grab_default(ok);
+
+	cancel = gtk_button_new_with_label(_("Cancel"));
+	gtk_signal_connect_object(GTK_OBJECT(cancel), "clicked", GTK_SIGNAL_FUNC(gtk_widget_destroy), GTK_OBJECT(configure_win));
+	GTK_WIDGET_SET_FLAGS(cancel, GTK_CAN_DEFAULT);
+	gtk_box_pack_start(GTK_BOX(bbox), cancel, TRUE, TRUE, 0);
+
+	gtk_widget_show_all(configure_win);
+}
+#endif
diff -uNr xmms-1.2.10/Output/nbs/convert.c xmms-1.2.10-nbs/Output/nbs/convert.c
--- xmms-1.2.10/Output/nbs/convert.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.10-nbs/Output/nbs/convert.c	2004-04-16 08:43:24.000000000 -0500
@@ -0,0 +1,287 @@
+/*
+ *  Copyright (C) 2001  Haavard Kvaalen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "xmmsnbs.h"
+#include <nbs.h>
+
+void* nbs_get_convert_buffer(size_t size)
+{
+	static size_t length;
+	static void *buffer;
+
+	if (size > 0 && size <= length)
+		return buffer;
+
+	length = size;
+	buffer = g_realloc(buffer, size);
+	return buffer;
+}
+
+static int convert_swap_endian(void **data, int length)
+{
+	guint16 *ptr = *data;
+	int i;
+	for (i = 0; i < length; i += 2, ptr++)
+		*ptr = GUINT16_SWAP_LE_BE(*ptr);
+
+	return i;
+}
+
+static int convert_swap_sign_and_endian_to_native(void **data, int length)
+{
+	guint16 *ptr = *data;
+	int i;
+	for (i = 0; i < length; i += 2, ptr++)
+		*ptr = GUINT16_SWAP_LE_BE(*ptr) ^ 1 << 15;
+
+	return i;
+}
+
+static int convert_swap_sign_and_endian_to_alien(void **data, int length)
+{
+	guint16 *ptr = *data;
+	int i;
+	for (i = 0; i < length; i += 2, ptr++)
+		*ptr = GUINT16_SWAP_LE_BE(*ptr ^ 1 << 15);
+
+	return i;
+}
+
+static int convert_swap_sign16(void **data, int length)
+{
+	gint16 *ptr = *data;
+	int i;
+	for (i = 0; i < length; i += 2, ptr++)
+		*ptr ^= 1 << 15;
+
+	return i;
+}
+
+static int convert_swap_sign8(void **data, int length)
+{
+	gint8 *ptr = *data;
+	int i;
+	for (i = 0; i < length; i++)
+		*ptr++ ^= 1 << 7;
+
+	return i;
+}
+
+static int convert_to_8_native_endian(void **data, int length)
+{
+	gint8 *output = *data;
+	gint16 *input = *data;
+	int i;
+	for (i = 0; i < length / 2; i++)
+		*output++ = *input++ >> 8;
+
+	return i;
+}
+
+static int convert_to_8_native_endian_swap_sign(void **data, int length)
+{
+	gint8 *output = *data;
+	gint16 *input = *data;
+	int i;
+	for (i = 0; i < length / 2; i++)
+		*output++ = (*input++ >> 8) ^ (1 << 7);
+
+	return i;
+}
+
+
+static int convert_to_8_alien_endian(void **data, int length)
+{
+	gint8 *output = *data;
+	gint16 *input = *data;
+	int i;
+	for (i = 0; i < length / 2; i++)
+		*output++ = *input++ & 0xff;
+
+	return i;
+}
+
+static int convert_to_8_alien_endian_swap_sign(void **data, int length)
+{
+	gint8 *output = *data;
+	gint16 *input = *data;
+	int i;
+	for (i = 0; i < length / 2; i++)
+		*output++ = (*input++ & 0xff) ^ (1 << 7);
+
+	return i;
+}
+
+static int convert_to_16_native_endian(void **data, int length)
+{
+	guint8 *input = *data;
+	guint16 *output;
+	int i;
+	*data = nbs_get_convert_buffer(length * 2);
+	output = *data;
+	for (i = 0; i < length; i++)
+		*output++ = *input++ << 8;
+
+	return i * 2;
+}
+
+static int convert_to_16_native_endian_swap_sign(void **data, int length)
+{
+	guint8 *input = *data;
+	guint16 *output;
+	int i;
+	*data = nbs_get_convert_buffer(length * 2);
+	output = *data;
+	for (i = 0; i < length; i++)
+		*output++ = (*input++ << 8) ^ (1 << 15);
+
+	return i * 2;
+}
+
+
+static int convert_to_16_alien_endian(void **data, int length)
+{
+	guint8 *input = *data;
+	guint16 *output;
+	int i;
+	*data = nbs_get_convert_buffer(length * 2);
+	output = *data;
+	for (i = 0; i < length; i++)
+		*output++ = *input++;
+
+	return i * 2;
+}
+
+static int convert_to_16_alien_endian_swap_sign(void **data, int length)
+{
+	guint8 *input = *data;
+	guint16 *output;
+	int i;
+	*data = nbs_get_convert_buffer(length * 2);
+	output = *data;
+	for (i = 0; i < length; i++)
+		*output++ = *input++ ^ (1 << 7);
+
+	return i * 2;
+}
+
+int (*nbs_get_convert_func(int output, int input))(void **, int)
+{
+	if (output == input)
+		return NULL;
+
+	if ((output == NBS_FMT_U16_BE && input == NBS_FMT_U16_LE) ||
+	    (output == NBS_FMT_U16_LE && input == NBS_FMT_U16_BE) ||
+	    (output == NBS_FMT_S16_BE && input == NBS_FMT_S16_LE) ||
+	    (output == NBS_FMT_S16_LE && input == NBS_FMT_S16_BE))
+		return convert_swap_endian;
+
+	if ((output == NBS_FMT_U16_BE && input == NBS_FMT_S16_BE) ||
+	    (output == NBS_FMT_U16_LE && input == NBS_FMT_S16_LE) ||
+	    (output == NBS_FMT_S16_BE && input == NBS_FMT_U16_BE) ||
+	    (output == NBS_FMT_S16_LE && input == NBS_FMT_U16_LE))
+		return convert_swap_sign16;
+
+	if ((IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_S16_LE) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_U16_LE))) ||
+	    (!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_S16_BE) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_U16_BE))))
+		return convert_swap_sign_and_endian_to_native;
+		
+	if ((!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_S16_LE) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_U16_LE))) ||
+	    (IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_S16_BE) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_U16_BE))))
+		return convert_swap_sign_and_endian_to_alien;
+
+	if ((IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_U16_BE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_S16_BE))) ||
+	    (!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_U16_LE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_S16_LE))))
+		return convert_to_8_native_endian;
+
+	if ((IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_S16_BE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_U16_BE))) ||
+	    (!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_S16_LE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_U16_LE))))
+		return convert_to_8_native_endian_swap_sign;
+
+	if ((!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_U16_BE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_S16_BE))) ||
+	    (IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_U16_LE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_S16_LE))))
+		return convert_to_8_alien_endian;
+
+	if ((!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_S16_BE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_U16_BE))) ||
+	    (IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_S16_LE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_U16_LE))))
+		return convert_to_8_alien_endian_swap_sign;
+
+	if ((output == NBS_FMT_U8 && input == NBS_FMT_S8) ||
+	    (output == NBS_FMT_S8 && input == NBS_FMT_U8))
+		return convert_swap_sign8;
+
+	if ((IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_U8) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_S8))) ||
+	    (!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_U8) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_S8))))
+		return convert_to_16_native_endian;
+
+	if ((IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_S8) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_U8))) ||
+	    (!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_S8) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_U8))))
+		return convert_to_16_native_endian_swap_sign;
+
+	if ((!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_U8) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_S8))) ||
+	    (IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_U8) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_S8))))
+		return convert_to_16_alien_endian;
+
+	if ((!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_S8) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_U8))) ||
+	    (IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_S8) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_U8))))
+		return convert_to_16_alien_endian_swap_sign;
+
+	g_warning("Translation needed, but not available.\n"
+		  "Input: %d; Output %d.", input, output);
+	return NULL;
+}
diff -uNr xmms-1.2.10/Output/nbs/init.c xmms-1.2.10-nbs/Output/nbs/init.c
--- xmms-1.2.10/Output/nbs/init.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.10-nbs/Output/nbs/init.c	2004-04-16 08:43:24.000000000 -0500
@@ -0,0 +1,50 @@
+/*  XMMS - Crnbs-platform multimedia player
+ *  Copyright (C) 1998-2000  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmmsnbs.h"
+#include "libxmms/configfile.h"
+
+NBSConfig nbs_cfg;
+
+void nbs_init(void)
+{
+	ConfigFile *cfgfile;
+
+	memset(&nbs_cfg, 0, sizeof (NBSConfig));
+
+	nbs_cfg.audio_device = 0;
+	nbs_cfg.mixer_device = 0;
+	nbs_cfg.buffer_size = 3000;
+	nbs_cfg.prebuffer = 25;
+	nbs_cfg.use_alt_audio_device = FALSE;
+	nbs_cfg.alt_audio_device = NULL;
+	nbs_cfg.use_master=0;
+	
+	if ((cfgfile = xmms_cfg_open_default_file()))
+	{
+		xmms_cfg_read_int(cfgfile, "NBS", "audio_device", &nbs_cfg.audio_device);
+		xmms_cfg_read_int(cfgfile, "NBS", "mixer_device", &nbs_cfg.mixer_device);
+		xmms_cfg_read_int(cfgfile, "NBS", "buffer_size", &nbs_cfg.buffer_size);
+		xmms_cfg_read_int(cfgfile, "NBS", "prebuffer", &nbs_cfg.prebuffer);
+		xmms_cfg_read_boolean(cfgfile, "NBS", "use_master", &nbs_cfg.use_master);
+		xmms_cfg_read_boolean(cfgfile, "NBS", "use_alt_audio_device", &nbs_cfg.use_alt_audio_device);
+		xmms_cfg_read_string(cfgfile, "NBS", "alt_audio_device", &nbs_cfg.alt_audio_device);
+		xmms_cfg_read_boolean(cfgfile, "NBS", "use_alt_mixer_device", &nbs_cfg.use_alt_mixer_device);
+		xmms_cfg_read_string(cfgfile, "NBS", "alt_mixer_device", &nbs_cfg.alt_mixer_device);
+		xmms_cfg_free(cfgfile);
+	}
+}
diff -uNr xmms-1.2.10/Output/nbs/Makefile.am xmms-1.2.10-nbs/Output/nbs/Makefile.am
--- xmms-1.2.10/Output/nbs/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.10-nbs/Output/nbs/Makefile.am	2004-04-16 08:43:42.000000000 -0500
@@ -0,0 +1,32 @@
+nbssources = nbs.c \
+mixer.c \
+about.c \
+configure.c \
+audio.c \
+init.c \
+convert.c \
+xmmsnbs.h
+
+if HAVE_NBS
+
+nbsltlibs = libNBS.la
+nbsbuildsources = $(nbssources)
+
+
+else
+
+nbsltlibs =
+nbsbuildsources =
+
+endif
+
+EXTRA_DIST = $(nbssources)
+
+lib_LTLIBRARIES = $(nbsltlibs)
+
+libdir = $(plugindir)/$(OUTPUT_PLUGIN_DIR)
+
+libNBS_la_LDFLAGS = @PLUGIN_LDFLAGS@
+libNBS_la_LIBADD = @GTK_LIBS@ @PTHREAD_LIBS@ -lnbs
+libNBS_la_SOURCES= $(nbsbuildsources)
+INCLUDES = @GTK_CFLAGS@ -I$(top_builddir)/intl -I$(top_srcdir)
diff -uNr xmms-1.2.10/Output/nbs/Makefile.in xmms-1.2.10-nbs/Output/nbs/Makefile.in
--- xmms-1.2.10/Output/nbs/Makefile.in	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.10-nbs/Output/nbs/Makefile.in	2004-04-16 08:43:51.000000000 -0500
@@ -0,0 +1,557 @@
+# Makefile.in generated by automake 1.7.8 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
+ALSA_CFLAGS = @ALSA_CFLAGS@
+ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+ARCH_DEFINES = @ARCH_DEFINES@
+ARCH_X86_FALSE = @ARCH_X86_FALSE@
+ARCH_X86_TRUE = @ARCH_X86_TRUE@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BUILD_INCLUDED_LIBINTL = @BUILD_INCLUDED_LIBINTL@
+CATOBJEXT = @CATOBJEXT@
+CC = @CC@
+CCAS = @CCAS@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EFFECT_PLUGINS = @EFFECT_PLUGINS@
+EFFECT_PLUGIN_DIR = @EFFECT_PLUGIN_DIR@
+EGREP = @EGREP@
+ESD_CFLAGS = @ESD_CFLAGS@
+ESD_CONFIG = @ESD_CONFIG@
+ESD_LIBS = @ESD_LIBS@
+EXEEXT = @EXEEXT@
+GENCAT = @GENCAT@
+GENERAL_PLUGINS = @GENERAL_PLUGINS@
+GENERAL_PLUGIN_DIR = @GENERAL_PLUGIN_DIR@
+GLIBC21 = @GLIBC21@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_CONFIG = @GLIB_CONFIG@
+GLIB_LIBS = @GLIB_LIBS@
+GMSGFMT = @GMSGFMT@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_CONFIG = @GTK_CONFIG@
+GTK_LIBS = @GTK_LIBS@
+HAVE_ALSA_FALSE = @HAVE_ALSA_FALSE@
+HAVE_ALSA_TRUE = @HAVE_ALSA_TRUE@
+HAVE_CDROM_FALSE = @HAVE_CDROM_FALSE@
+HAVE_CDROM_TRUE = @HAVE_CDROM_TRUE@
+HAVE_ESD_FALSE = @HAVE_ESD_FALSE@
+HAVE_ESD_TRUE = @HAVE_ESD_TRUE@
+HAVE_LINUX_JOYSTICK_FALSE = @HAVE_LINUX_JOYSTICK_FALSE@
+HAVE_LINUX_JOYSTICK_TRUE = @HAVE_LINUX_JOYSTICK_TRUE@
+HAVE_MIKMOD_FALSE = @HAVE_MIKMOD_FALSE@
+HAVE_MIKMOD_TRUE = @HAVE_MIKMOD_TRUE@
+HAVE_OGGVORBIS_FALSE = @HAVE_OGGVORBIS_FALSE@
+HAVE_OGGVORBIS_TRUE = @HAVE_OGGVORBIS_TRUE@
+HAVE_OPENGL_FALSE = @HAVE_OPENGL_FALSE@
+HAVE_OPENGL_TRUE = @HAVE_OPENGL_TRUE@
+HAVE_NBS_FALSE = @HAVE_NBS_FALSE@
+HAVE_NBS_TRUE = @HAVE_NBS_TRUE@
+HAVE_SOLARIS_FALSE = @HAVE_SOLARIS_FALSE@
+HAVE_SOLARIS_TRUE = @HAVE_SOLARIS_TRUE@
+HAVE_SUN_FALSE = @HAVE_SUN_FALSE@
+HAVE_SUN_TRUE = @HAVE_SUN_TRUE@
+INPUT_PLUGINS = @INPUT_PLUGINS@
+INPUT_PLUGIN_DIR = @INPUT_PLUGIN_DIR@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLBISON = @INTLBISON@
+INTLLIBS = @INTLLIBS@
+INTLOBJS = @INTLOBJS@
+INTL_LIBTOOL_SUFFIX_PREFIX = @INTL_LIBTOOL_SUFFIX_PREFIX@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBINTL = @LIBINTL@
+LIBMIKMOD_CFLAGS = @LIBMIKMOD_CFLAGS@
+LIBMIKMOD_CONFIG = @LIBMIKMOD_CONFIG@
+LIBMIKMOD_LDADD = @LIBMIKMOD_LDADD@
+LIBMIKMOD_LIBS = @LIBMIKMOD_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
+OBJEXT = @OBJEXT@
+OGG_CFLAGS = @OGG_CFLAGS@
+OGG_LIBS = @OGG_LIBS@
+OPENGL_LIBS = @OPENGL_LIBS@
+OUTPUT_PLUGINS = @OUTPUT_PLUGINS@
+OUTPUT_PLUGIN_DIR = @OUTPUT_PLUGIN_DIR@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PLUGIN_LDFLAGS = @PLUGIN_LDFLAGS@
+POSIX_LIBS = @POSIX_LIBS@
+POSUB = @POSUB@
+PTHREAD_LIBS = @PTHREAD_LIBS@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SM_LIBS = @SM_LIBS@
+STRIP = @STRIP@
+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@
+USE_IPV6 = @USE_IPV6@
+USE_IPV6_FALSE = @USE_IPV6_FALSE@
+USE_IPV6_TRUE = @USE_IPV6_TRUE@
+USE_NLS = @USE_NLS@
+USE_SIMD_FALSE = @USE_SIMD_FALSE@
+USE_SIMD_TRUE = @USE_SIMD_TRUE@
+USE_X86ASM_FALSE = @USE_X86ASM_FALSE@
+USE_X86ASM_TRUE = @USE_X86ASM_TRUE@
+VERSION = @VERSION@
+VISUALIZATION_PLUGINS = @VISUALIZATION_PLUGINS@
+VISUALIZATION_PLUGIN_DIR = @VISUALIZATION_PLUGIN_DIR@
+VM_LIBS = @VM_LIBS@
+VORBISENC_LIBS = @VORBISENC_LIBS@
+VORBISFILE_LIBS = @VORBISFILE_LIBS@
+VORBIS_CFLAGS = @VORBIS_CFLAGS@
+VORBIS_LIBS = @VORBIS_LIBS@
+XGETTEXT = @XGETTEXT@
+XMMS_DEFINES = @XMMS_DEFINES@
+XMMS_PATH = @XMMS_PATH@
+Z_LIBS = @Z_LIBS@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_prefix_program = @ac_prefix_program@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+
+libdir = $(plugindir)/$(OUTPUT_PLUGIN_DIR)
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+plugindir = @plugindir@
+pluginsubs = @pluginsubs@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+subdirs = @subdirs@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+xmmsdir = @xmmsdir@
+nbssources = NBS.c NBS.h \
+mixer.c \
+about.c \
+configure.c \
+audio.c \
+init.c \
+convert.c \
+soundcard.h
+
+
+@HAVE_NBS_TRUE@nbsltlibs = libNBS.la
+
+@HAVE_NBS_FALSE@nbsltlibs = 
+@HAVE_NBS_TRUE@nbsbuildsources = $(nbssources)
+@HAVE_NBS_FALSE@nbsbuildsources = 
+
+EXTRA_DIST = $(nbssources)
+
+lib_LTLIBRARIES = $(nbsltlibs)
+
+libNBS_la_LDFLAGS = @PLUGIN_LDFLAGS@
+libNBS_la_LIBADD = @GTK_LIBS@ @PTHREAD_LIBS@ -lnbs
+libNBS_la_SOURCES = $(nbsbuildsources)
+INCLUDES = @GTK_CFLAGS@ -I$(top_builddir)/intl -I$(top_srcdir)
+subdir = Output/nbs
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/xmms/i18n.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(lib_LTLIBRARIES)
+
+libNBS_la_DEPENDENCIES =
+am__libNBS_la_SOURCES_DIST = NBS.c NBS.h mixer.c about.c configure.c \
+	audio.c init.c convert.c soundcard.h
+am__objects_1 = NBS.lo mixer.lo about.lo configure.lo audio.lo init.lo \
+	convert.lo
+@HAVE_NBS_TRUE@am__objects_2 = $(am__objects_1)
+@HAVE_NBS_FALSE@am__objects_2 =
+am_libNBS_la_OBJECTS = $(am__objects_2)
+libNBS_la_OBJECTS = $(am_libNBS_la_OBJECTS)
+
+DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir) -I$(top_builddir)/xmms
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/NBS.Plo ./$(DEPDIR)/about.Plo \
+@AMDEP_TRUE@	./$(DEPDIR)/audio.Plo ./$(DEPDIR)/configure.Plo \
+@AMDEP_TRUE@	./$(DEPDIR)/convert.Plo ./$(DEPDIR)/init.Plo \
+@AMDEP_TRUE@	./$(DEPDIR)/mixer.Plo
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) \
+	$(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+DIST_SOURCES = $(am__libNBS_la_SOURCES_DIST)
+DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
+SOURCES = $(libNBS_la_SOURCES)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  Output/nbs/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+libLTLIBRARIES_INSTALL = $(INSTALL)
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libdir)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f="`echo $$p | sed -e 's|^.*/||'`"; \
+	    echo " $(LIBTOOL) --mode=install $(libLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) $$p $(DESTDIR)$(libdir)/$$f"; \
+	    $(LIBTOOL) --mode=install $(libLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) $$p $(DESTDIR)$(libdir)/$$f; \
+	  else :; fi; \
+	done
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	    p="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$$p"; \
+	  $(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$$p; \
+	done
+
+clean-libLTLIBRARIES:
+	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" = "$$p" && dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libNBS.la: $(libNBS_la_OBJECTS) $(libNBS_la_DEPENDENCIES) 
+	$(LINK) -rpath $(libdir) $(libNBS_la_LDFLAGS) $(libNBS_la_OBJECTS) $(libNBS_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT) core *.core
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/NBS.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/about.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/audio.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/configure.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/convert.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/init.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mixer.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+@am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+@am__fastdepCC_TRUE@	fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+@am__fastdepCC_TRUE@	  -c -o $@ `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+@am__fastdepCC_TRUE@	fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`
+
+.c.lo:
+@am__fastdepCC_TRUE@	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+@am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; \
+@am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+@am__fastdepCC_TRUE@	fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Plo' tmpdepfile='$(DEPDIR)/$*.TPlo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libdir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-libLTLIBRARIES
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libLTLIBRARIES
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libLTLIBRARIES clean-libtool ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am info info-am install \
+	install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am \
+	install-libLTLIBRARIES install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-info-am \
+	uninstall-libLTLIBRARIES
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -uNr xmms-1.2.10/Output/nbs/mixer.c xmms-1.2.10-nbs/Output/nbs/mixer.c
--- xmms-1.2.10/Output/nbs/mixer.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.10-nbs/Output/nbs/mixer.c	2004-04-16 08:43:24.000000000 -0500
@@ -0,0 +1,98 @@
+/*  XMMS - Cross-platform multimedia player
+ *  Copyright (C) 1998-2000  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "nbs.h"
+#include <errno.h>
+
+#if 0
+/* One day I'll have an NBS Mixer and it will go here.... */
+static char* get_mixer_device(void)
+{
+	char *name;
+	
+	if (oss_cfg.use_alt_mixer_device && oss_cfg.alt_mixer_device)
+		name = g_strdup(oss_cfg.alt_mixer_device);
+	else if (oss_cfg.mixer_device > 0)
+		name = g_strdup_printf("%s%d", DEV_MIXER, oss_cfg.mixer_device);
+	else
+		name = g_strdup(DEV_MIXER);
+
+	return name;
+}
+
+void oss_get_volume(int *l, int *r)
+{
+	int fd, v, cmd, devs;
+	gchar *devname;
+
+	devname = get_mixer_device();
+	fd = open(devname, O_RDONLY);
+	g_free(devname);
+
+	/*
+	 * We dont show any errors if this fails, as this is called
+	 * rather often
+	 */
+	if (fd != -1)
+	{
+		ioctl(fd, SOUND_MIXER_READ_DEVMASK, &devs);
+		if ((devs & SOUND_MASK_PCM) && (oss_cfg.use_master==0))
+			cmd = SOUND_MIXER_READ_PCM;
+		else if ((devs & SOUND_MASK_VOLUME) && (oss_cfg.use_master==1))
+			cmd = SOUND_MIXER_READ_VOLUME;
+		else
+		{
+			close(fd);
+			return;
+		}
+		ioctl(fd, cmd, &v);
+		*r = (v & 0xFF00) >> 8;
+		*l = (v & 0x00FF);
+		close(fd);
+	}
+}
+
+void oss_set_volume(int l, int r)
+{
+	int fd, v, cmd, devs;
+	gchar *devname;
+
+	devname = get_mixer_device();
+	fd = open(devname, O_RDONLY);
+
+	if (fd != -1)
+	{
+		ioctl(fd, SOUND_MIXER_READ_DEVMASK, &devs);
+		if ((devs & SOUND_MASK_PCM) && (oss_cfg.use_master==0))
+			cmd = SOUND_MIXER_WRITE_PCM;
+		else if ((devs & SOUND_MASK_VOLUME) && (oss_cfg.use_master==1))
+			cmd = SOUND_MIXER_WRITE_VOLUME;
+		else
+		{
+			close(fd);
+			return;
+		}
+		v = (r << 8) | l;
+		ioctl(fd, cmd, &v);
+		close(fd);
+	}
+	else
+		g_warning("oss_set_volume(): Failed to open mixer device (%s): %s",
+			  devname, strerror(errno));
+	g_free(devname);
+}
+#endif
diff -uNr xmms-1.2.10/Output/nbs/nbs.c xmms-1.2.10-nbs/Output/nbs/nbs.c
--- xmms-1.2.10/Output/nbs/nbs.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.10-nbs/Output/nbs/nbs.c	2004-04-16 08:43:24.000000000 -0500
@@ -0,0 +1,48 @@
+/*  XMMS - Crnbs-platform multimedia player
+ *  Copyright (C) 1998-2000  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *
+ *  Modified by Mark Spencer <markster@digium.com> to support NBS
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmmsnbs.h"
+#include "xmms/i18n.h"
+
+OutputPlugin nbs_op =
+{
+	NULL,
+	NULL,
+	NULL, /* Description */
+	NULL, /* nbs_init, */
+	nbs_about,
+	NULL, /* nbs_configure, */
+	NULL, /* nbs_get_volume, */
+	NULL, /* nbs_set_volume, */
+	nbs_open,
+	nbs_xwrite,
+	nbs_close,
+	nbs_flush,
+	nbs_pause,
+	nbs_free,
+	nbs_playing,
+	nbs_get_output_time,
+	nbs_get_written_time,
+};
+
+OutputPlugin *get_oplugin_info(void)
+{
+	nbs_op.description = g_strdup_printf(_("NBS Driver %s"), VERSION);
+	return &nbs_op;
+}
diff -uNr xmms-1.2.10/Output/nbs/xmmsnbs.h xmms-1.2.10-nbs/Output/nbs/xmmsnbs.h
--- xmms-1.2.10/Output/nbs/xmmsnbs.h	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.10-nbs/Output/nbs/xmmsnbs.h	2004-04-16 08:43:24.000000000 -0500
@@ -0,0 +1,85 @@
+/*  XMMS - Crnbs-platform multimedia player
+ *  Copyright (C) 1998-2000  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef _XMMS_NBS_H
+#define _XMMS_NBS_H
+
+#include "config.h"
+
+#include <gtk/gtk.h>
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <nbs.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "xmms/plugin.h"
+#include "libxmms/configfile.h"
+
+#ifdef WORDS_BIGENDIAN
+# define IS_BIG_ENDIAN TRUE
+#else
+# define IS_BIG_ENDIAN FALSE
+#endif
+
+extern OutputPlugin op;
+
+typedef struct
+{
+	gint audio_device;
+	gint mixer_device;
+	gint buffer_size;
+	gint prebuffer;
+	gboolean use_master;
+	gboolean use_alt_audio_device, use_alt_mixer_device;
+	gchar *alt_audio_device, *alt_mixer_device;
+}
+NBSConfig;
+
+extern NBSConfig nbs_cfg;
+
+void nbs_init(void);
+void nbs_about(void);
+void nbs_configure(void);
+
+void nbs_get_volume(int *l, int *r);
+void nbs_set_volume(int l, int r);
+
+int nbs_playing(void);
+int nbs_free(void);
+void nbs_xwrite(void *ptr, int length);
+void nbs_close(void);
+void nbs_flush(int time);
+void nbs_pause(short p);
+int nbs_open(AFormat fmt, int rate, int nch);
+int nbs_get_output_time(void);
+int nbs_get_written_time(void);
+void nbs_set_audio_params(void);
+
+void* nbs_get_convert_buffer(size_t size);
+int (*nbs_get_convert_func(int output, int input))(void **, int);
+
+#endif
