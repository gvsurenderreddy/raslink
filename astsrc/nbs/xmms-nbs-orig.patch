diff -uNr xmms-1.2.7/configure.in xmms-1.2.7-nbsworking/configure.in
--- xmms-1.2.7/configure.in	2003-01-21 03:24:18.000000000 -0600
+++ xmms-1.2.7-nbsworking/configure.in	2003-01-20 09:56:47.000000000 -0600
@@ -616,6 +616,7 @@
 Output/esd/Makefile
 Output/disk_writer/Makefile
 Output/solaris/Makefile
+Output/nbs/Makefile
 Input/Makefile
 Input/wav/Makefile
 Input/mpg123/Makefile
Binary files xmms-1.2.7/libzz_mp3.so and xmms-1.2.7-nbsworking/libzz_mp3.so differ
diff -uNr xmms-1.2.7/Output/Makefile.am xmms-1.2.7-nbsworking/Output/Makefile.am
--- xmms-1.2.7/Output/Makefile.am	2001-03-08 08:33:29.000000000 -0600
+++ xmms-1.2.7-nbsworking/Output/Makefile.am	2003-01-20 09:56:47.000000000 -0600
@@ -1,2 +1,2 @@
-ALL_PLUGINS = OSS esd disk_writer solaris
+ALL_PLUGINS = OSS esd disk_writer solaris nbs
 SUBDIRS = @OUTPUT_PLUGINS@
diff -uNr xmms-1.2.7/Output/nbs/about.c xmms-1.2.7-nbsworking/Output/nbs/about.c
--- xmms-1.2.7/Output/nbs/about.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.7-nbsworking/Output/nbs/about.c	2003-01-20 10:02:42.000000000 -0600
@@ -0,0 +1,49 @@
+/*  XMMS - Cross-platform multimedia player
+ *  Copyright (C) 1998-2000  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmms/i18n.h"
+#include "nbs.h"
+#include "libxmms/util.h"
+
+void nbs_about(void)
+{
+	static GtkWidget *dialog;
+
+	if (dialog != NULL)
+		return;
+	
+	dialog = xmms_show_message(
+		_("About NBS Driver"),
+		_("XMMS NBS Driver\n\n "
+		  "This program is free software; you can redistribute it and/or modify\n"
+		  "it under the terms of the GNU General Public License as published by\n"
+		  "the Free Software Foundation; either version 2 of the License, or\n"
+		  "(at your option) any later version.\n"
+		  "\n"
+		  "This program is distributed in the hope that it will be useful,\n"
+		  "but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
+		  "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
+		  "GNU General Public License for more details.\n"
+		  "\n"
+		  "You should have received a copy of the GNU General Public License\n"
+		  "along with this program; if not, write to the Free Software\n"
+		  "Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n"
+		  "USA."), _("Ok"), FALSE, NULL, NULL);
+	gtk_signal_connect(GTK_OBJECT(dialog), "destroy",
+			   GTK_SIGNAL_FUNC(gtk_widget_destroyed),
+			   &dialog);
+}
diff -uNr xmms-1.2.7/Output/nbs/audio.c xmms-1.2.7-nbsworking/Output/nbs/audio.c
--- xmms-1.2.7/Output/nbs/audio.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.7-nbsworking/Output/nbs/audio.c	2003-01-21 01:44:35.000000000 -0600
@@ -0,0 +1,756 @@
+/*  XMMS - Crnbs-platform multimedia player
+ *  Copyright (C) 1998-2001  Peter Alm, Mikael Alm, Olle Hallnas,
+ *                           Thomas Nilsson and 4Front Technologies
+ *  Copyright (C) 1999-2001  Haavard Kvaalen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmmsnbs.h"
+#include "libxmms/util.h"
+#include <errno.h>
+#include <nbs.h>
+
+#define NFRAGS		32
+
+static char *buffer;
+static gboolean going, prebuffer, paused, unpause, do_pause, remove_prebuffer;
+static gint device_buffer_used, buffer_size, prebuffer_size, blk_size = 4096;
+static gint rd_index = 0, wr_index = 0;
+static gint output_time_offset = 0;
+static guint64 written = 0, output_bytes = 0;
+static gint flush;
+static gint fragsize, device_buffer_size;
+static gchar *device_name;
+static pthread_t buffer_thread;
+static gboolean realtime, select_works;
+static int realchannels;
+static NBS *nbs;
+
+static int (*nbs_convert_func)(void **data, int length);
+
+struct format_info {
+	union {
+		AFormat xmms;
+		int nbs;
+	} format;
+	int frequency;
+	int channels;
+	int bps;
+};
+
+
+/*
+ * The format of the data from the input plugin
+ * This will never change during a song. 
+ */
+struct format_info input;
+
+/*
+ * The format we get from the effect plugin.
+ * This will be different from input if the effect plugin does
+ * some kind of format conversion.
+ */
+struct format_info effect;
+
+/*
+ * The format of the data we actually send to the soundcard.
+ * This might be different from effect if we need to resample or do
+ * some other format conversion.
+ */
+struct format_info output;
+
+
+#if 0
+static void nbs_calc_device_buffer_used(void)
+{
+	audio_buf_info buf_info;
+	if(paused)
+		device_buffer_used = 0;
+	else if (!ioctl(fd, SNDCTL_DSP_GETOSPACE, &buf_info))
+		device_buffer_used = (buf_info.fragstotal * buf_info.fragsize) - buf_info.bytes;
+}
+#endif
+
+
+static gint nbs_downsample(gpointer ob, guint length, guint speed, guint espeed);
+
+static int nbs_calc_bitrate(int nbs_fmt, int rate, int channels)
+{
+	int bitrate = rate * channels;
+
+	if (nbs_fmt == NBS_FMT_U16_BE || nbs_fmt == NBS_FMT_U16_LE ||
+	    nbs_fmt == NBS_FMT_S16_BE || nbs_fmt == NBS_FMT_S16_LE)
+		bitrate *= 2;
+
+	return bitrate;
+}
+
+static int nbs_get_format(AFormat fmt)
+{
+	int format = 0;
+
+	switch (fmt)
+	{
+		case FMT_U8:
+			format = NBS_FMT_U8;
+			break;
+		case FMT_S8:
+			format = NBS_FMT_S8;
+			break;
+		case FMT_U16_LE:
+			format = NBS_FMT_U16_LE;
+			break;
+		case FMT_U16_BE:
+			format = NBS_FMT_U16_BE;
+			break;
+		case FMT_U16_NE:
+#ifdef WORDS_BIGENDIAN
+			format = NBS_FMT_U16_BE;
+#else
+			format = NBS_FMT_U16_LE;
+#endif
+			break;
+		case FMT_S16_LE:
+			format = NBS_FMT_S16_LE;
+			break;
+		case FMT_S16_BE:
+			format = NBS_FMT_S16_BE;
+			break;
+		case FMT_S16_NE:
+#ifdef WORDS_BIGENDIAN
+			format = NBS_FMT_S16_BE;
+#else
+			format = NBS_FMT_S16_LE;
+#endif
+			break;
+	}
+
+	return format;
+}
+
+static void nbs_setup_format(AFormat fmt, int rate, int nch)
+{
+	effect.format.xmms = fmt;
+	effect.frequency = rate;
+	effect.channels = nch;
+	effect.bps = nbs_calc_bitrate(nbs_get_format(fmt), rate, nch);
+
+	/* Output is fixed format for NBS */
+	output.format.nbs = NBS_FORMAT;
+	output.frequency = NBS_BITRATE;
+	output.channels = NBS_CHANNELS;
+
+
+	nbs_set_audio_params();
+
+	output.bps = nbs_calc_bitrate(output.format.nbs, output.frequency,
+				      output.channels);
+}
+	
+
+gint nbs_get_written_time(void)
+{
+	if (!going)
+		return 0;
+	return (written * 1000) / effect.bps;
+}
+
+gint nbs_get_output_time(void)
+{
+	guint64 bytes;
+
+	if (!nbs || !going)
+		return 0;
+
+	bytes = output_bytes < device_buffer_used ?
+		0 : output_bytes - device_buffer_used;
+
+	return output_time_offset + ((bytes * 1000) / output.bps);
+}
+
+static int nbs_used(void)
+{
+	if (realtime)
+		return 0;
+	else
+	{
+		if (wr_index >= rd_index)
+			return wr_index - rd_index;
+		return buffer_size - (rd_index - wr_index);
+	}
+}
+
+gint nbs_playing(void)
+{
+	if(!going)
+		return 0;
+	if (!nbs_used() && (device_buffer_used - (3 * blk_size)) <= 0)
+		return FALSE;
+
+	return TRUE;
+}
+
+gint nbs_free(void)
+{
+	if (!realtime)
+	{
+		if (remove_prebuffer && prebuffer)
+		{
+			prebuffer = FALSE;
+			remove_prebuffer = FALSE;
+		}
+		if (prebuffer)
+			remove_prebuffer = TRUE;
+
+		if (rd_index > wr_index)
+			return (rd_index - wr_index) - device_buffer_size - 1;
+		return (buffer_size - (wr_index - rd_index)) - device_buffer_size - 1;
+	}
+	else
+		if (paused)
+			return 0;
+		else
+			return 1000000;
+}
+
+static inline ssize_t write_all(NBS *nbs, const void *buf, size_t count)
+{
+	ssize_t done = 0;
+	do {
+		ssize_t n = nbs_write(nbs, buf, (count - done) / (NBS_CHANNELS * 2));
+		if (n == -1)
+		{
+			if (errno == EINTR)
+				continue;
+			else
+				break;
+		}
+		done += n * (NBS_CHANNELS * 2);
+	} while (count > done);
+
+	return done;
+}
+
+static void make_stereo(gpointer dataout, gpointer datain, int length)
+{
+	/* Signededness doesn't matter for this operation */
+	unsigned short *ins = datain, *outs = dataout;
+	unsigned char *inc = datain, *outc = dataout;
+	int x;
+	switch (output.format.nbs)
+	{
+		case NBS_FMT_S16_BE:
+		case NBS_FMT_S16_LE:
+		case NBS_FMT_U16_BE:
+		case NBS_FMT_U16_LE:
+			for (x=0;x<length;x++)
+				outs[x] = ins[x >> 1];
+			break;
+		case NBS_FMT_S8:
+		case NBS_FMT_U8:
+			for (x=0;x<length<<1;x++)
+				outc[x] = inc[x >> 1];
+			break;
+	}
+}
+
+static void nbs_write_audio(gpointer data, int length)
+{
+	AFormat new_format;
+	int new_frequency, new_channels;
+	EffectPlugin *ep;
+	gpointer data2;
+	
+	
+	new_format = input.format.xmms;
+	new_frequency = input.frequency;
+	new_channels = input.channels;
+	
+	ep = get_current_effect_plugin();
+	if(effects_enabled() && ep && ep->query_format)
+	{
+		ep->query_format(&new_format,&new_frequency,&new_channels);
+	}
+	
+	if (new_format != effect.format.xmms ||
+	    new_frequency != effect.frequency ||
+	    new_channels != effect.channels)
+	{
+		output_time_offset += (output_bytes * 1000) / output.bps;
+		output_bytes = 0;
+		nbs_setup_format(new_format, new_frequency, new_channels);
+	}
+	if (effects_enabled() && ep && ep->mod_samples)
+		length = ep->mod_samples(&data, length,
+					 input.format.xmms,
+					 input.frequency,
+					 input.channels);
+	if (realtime)
+	{
+		while (nbs_freespace(nbs) < (length / (NBS_CHANNELS * 2)))
+		{
+			printf("Stuck sleeping waiting for %d...\n", length);
+			xmms_usleep(10000);
+		}
+	}
+
+	if (nbs_convert_func != NULL)
+		length = nbs_convert_func(&data, length);
+
+	if (effect.channels < realchannels) {
+		/* Gotta double for stereo-only cards */
+		data2 = alloca(length * 2);
+		if (!data2) {
+			static int warnedalready;
+			if (!warnedalready) {
+				g_warning("Unable to allocate memory for re-channelization: %s\n", strerror(errno));
+				warnedalready++;
+			}
+		} else {
+			make_stereo(data2, data, length);
+			data = data2;
+			length *= 2;
+		}
+	}
+
+	if (effect.frequency == output.frequency) {
+		if (nbs) {
+			output_bytes += nbs_write(nbs, data, length / (NBS_CHANNELS * 2)) * (NBS_CHANNELS * 2);
+		} else
+			g_warning("Trying to write with no NBS client\n");
+	} else {
+		output_bytes += nbs_downsample(data, length,
+					       effect.frequency,
+					       output.frequency);
+	}						   
+}
+
+static void swap_endian(guint16 *data, int length)
+{
+	int i;
+	for (i = 0; i < length; i += 2, data++)
+		*data = GUINT16_SWAP_LE_BE(*data);
+}
+
+#define NOT_NATIVE_ENDIAN ((IS_BIG_ENDIAN &&				\
+			   (output.format.nbs == NBS_FMT_S16_LE ||		\
+			    output.format.nbs == NBS_FMT_U16_LE)) ||	\
+			  (!IS_BIG_ENDIAN &&				\
+			   (output.format.nbs == NBS_FMT_S16_BE ||		\
+			    output.format.nbs == NBS_FMT_U16_BE)))
+
+
+#define RESAMPLE_STEREO(sample_type)				\
+do {								\
+	const gint shift = sizeof (sample_type);		\
+        gint i, in_samples, out_samples, x, delta;		\
+	sample_type *inptr = (sample_type *)ob, *outptr;	\
+	guint nlen = (((length >> shift) * espeed) / speed);	\
+	if (nlen == 0)						\
+		break;						\
+	nlen <<= shift;						\
+	if (NOT_NATIVE_ENDIAN)					\
+		swap_endian(ob, length);			\
+	if(nlen > nbuffer_size)					\
+	{							\
+		nbuffer = g_realloc(nbuffer, nlen);		\
+		nbuffer_size = nlen;				\
+	}							\
+	outptr = (sample_type *)nbuffer;			\
+	in_samples = length >> shift;				\
+        out_samples = nlen >> shift;				\
+	delta = (in_samples << 12) / out_samples;		\
+	for (x = 0, i = 0; i < out_samples; i++)		\
+	{							\
+		gint x1, frac;					\
+		x1 = (x >> 12) << 12;				\
+		frac = x - x1;					\
+		*outptr++ =					\
+			(sample_type)				\
+			((inptr[(x1 >> 12) << 1] *		\
+			  ((1<<12) - frac) +			\
+			  inptr[((x1 >> 12) + 1) << 1] *	\
+			  frac) >> 12);				\
+		*outptr++ =					\
+			(sample_type)				\
+			((inptr[((x1 >> 12) << 1) + 1] *	\
+			  ((1<<12) - frac) +			\
+			  inptr[(((x1 >> 12) + 1) << 1) + 1] *	\
+			  frac) >> 12);				\
+		x += delta;					\
+	}							\
+	if (NOT_NATIVE_ENDIAN)					\
+		swap_endian(nbuffer, nlen);			\
+	w = write_all(nbs, nbuffer, nlen);			\
+} while (0)
+
+
+#define RESAMPLE_MONO(sample_type)				\
+do {								\
+	const gint shift = sizeof (sample_type) - 1;		\
+        gint i, x, delta, in_samples, out_samples;		\
+	sample_type *inptr = (sample_type *)ob, *outptr;	\
+	guint nlen = (((length >> shift) * espeed) / speed);	\
+	if (nlen == 0)						\
+		break;						\
+	nlen <<= shift;						\
+	if (NOT_NATIVE_ENDIAN)					\
+		swap_endian(ob, length);			\
+	if(nlen > nbuffer_size)					\
+	{							\
+		nbuffer = g_realloc(nbuffer, nlen);		\
+		nbuffer_size = nlen;				\
+	}							\
+	outptr = (sample_type *)nbuffer;			\
+	in_samples = length >> shift;				\
+        out_samples = nlen >> shift;				\
+	delta = ((length >> shift) << 12) / out_samples;	\
+	for (x = 0, i = 0; i < out_samples; i++)		\
+	{							\
+		gint x1, frac;					\
+		x1 = (x >> 12) << 12;				\
+		frac = x - x1;					\
+		*outptr++ =					\
+			(sample_type)				\
+			((inptr[x1 >> 12] * ((1<<12) - frac) +	\
+			  inptr[(x1 >> 12) + 1] * frac) >> 12);	\
+		x += delta;					\
+	}							\
+	if (NOT_NATIVE_ENDIAN)					\
+		swap_endian(nbuffer, nlen);			\
+	w = write_all(nbs, nbuffer, nlen);			\
+} while (0)
+
+
+static gint nbs_downsample(gpointer ob, guint length, guint speed, guint espeed)
+{
+	guint w = 0;
+	static gpointer nbuffer = NULL;
+	static gint nbuffer_size = 0;
+
+	switch (output.format.nbs)
+	{
+		case NBS_FMT_S16_BE:
+		case NBS_FMT_S16_LE:
+			if (output.channels == 2)
+				RESAMPLE_STEREO(gint16);
+			else
+				RESAMPLE_MONO(gint16);
+			break;
+		case NBS_FMT_U16_BE:
+		case NBS_FMT_U16_LE:
+			if (output.channels == 2)
+				RESAMPLE_STEREO(guint16);
+			else
+				RESAMPLE_MONO(guint16);
+			break;
+		case NBS_FMT_S8:
+			if (output.channels == 2)
+				RESAMPLE_STEREO(gint8);
+			else
+				RESAMPLE_MONO(gint8);
+			break;
+		case NBS_FMT_U8:
+			if (output.channels == 2)
+				RESAMPLE_STEREO(guint8);
+			else
+				RESAMPLE_MONO(guint8);
+			break;
+	}
+	return w;
+}
+
+void nbs_xwrite(gpointer ptr, int length)
+{
+	int cnt, off = 0;
+
+	if (!realtime)
+	{
+		remove_prebuffer = FALSE;
+
+		written += length;
+		while (length > 0)
+		{
+			cnt = MIN(length, buffer_size - wr_index);
+			memcpy(buffer + wr_index, (char *)ptr + off, cnt);
+			wr_index = (wr_index + cnt) % buffer_size;
+			length -= cnt;
+			off += cnt;
+		}
+	}
+	else
+	{
+		if (paused)
+			return;
+		nbs_write_audio(ptr, length);
+		written += length;
+	}
+}
+
+void nbs_close(void)
+{
+	if (!going)
+		return;
+	going = 0;
+	if (!realtime)
+		pthread_join(buffer_thread, NULL);
+	else
+	{
+#if 0
+		ioctl(fd, SNDCTL_DSP_RESET, 0);
+		close(fd);
+#endif
+		if (nbs) {
+			nbs_delstream(nbs);
+			nbs = NULL;
+		}		
+	}
+	g_free(device_name);
+	nbs_get_convert_buffer(0);
+	wr_index = 0;
+	rd_index = 0;
+}
+
+void nbs_flush(gint time)
+{
+	if (!realtime)
+	{
+		flush = time;
+		while (flush != -1)
+			xmms_usleep(10000);
+	}
+	else
+	{
+#if 0
+		/* No concept of flushing */
+		ioctl(fd, SNDCTL_DSP_RESET, 0);
+		close(fd);
+		fd = open(device_name, O_WRONLY);
+		nbs_set_audio_params();
+		output_time_offset = time;
+		written = ((guint64)time * input.bps) / 1000;
+		output_bytes = 0;
+#endif		
+	}
+}
+
+void nbs_pause(short p)
+{
+	if (!realtime)
+	{
+		if (p == TRUE)
+			do_pause = TRUE;
+		else
+			unpause = TRUE;
+	}
+	else
+		paused = p;
+
+}
+
+void *nbs_loop(void *arg)
+{
+	gint length, cnt;
+	fd_set set;
+	struct timeval tv;
+
+	while (going)
+	{
+		if (nbs_used() > prebuffer_size)
+			prebuffer = FALSE;
+		if (nbs_used() > 0 && !paused && !prebuffer)
+		{
+			tv.tv_sec = 0;
+			tv.tv_usec = 10000;
+			FD_ZERO(&set);
+			FD_SET(nbs_fd(nbs), &set);
+			if(!select_works || (select(nbs_fd(nbs) + 1, NULL, &set, NULL, &tv) > 0))
+			{
+				length = MIN(blk_size, nbs_used());
+				while (length > 0)
+				{
+					cnt = MIN(length,buffer_size-rd_index);
+					nbs_write_audio(buffer + rd_index, cnt);
+					rd_index=(rd_index+cnt)%buffer_size;
+					length-=cnt;				
+				}
+			}
+		}
+		else
+			xmms_usleep(10000);
+		if (do_pause && !paused)
+		{
+			do_pause = FALSE;
+			paused = TRUE;
+#if 0
+			/* NBS has no flush */
+			/*
+			 * We lose some data here that is sent to the
+			 * soundcard, but not yet played.  I don't
+			 * think this is worth fixing.
+			 */
+			ioctl(fd, SNDCTL_DSP_RESET, 0);
+#endif			
+		}
+		else if (unpause && paused)
+		{
+			/* NBS has nothing really to have to do to unpause */
+			unpause = FALSE;
+#if 0
+			close(fd);
+			fd = open(device_name, O_WRONLY);
+			nbs_set_audio_params();
+#endif			
+			paused = FALSE;
+		}
+
+		if (flush != -1)
+		{
+			/*
+			 * This close and open is a work around of a
+			 * bug that exists in some drivers which cause
+			 * the driver to get fucked up by a reset
+			 */
+
+#if 0
+			ioctl(fd, SNDCTL_DSP_RESET, 0);
+			close(fd);
+			fd = open(device_name, O_WRONLY);
+			nbs_set_audio_params();
+#endif		
+			output_time_offset = flush;
+			written = ((guint64)flush * input.bps) / 1000;
+			rd_index = wr_index = output_bytes = 0;
+			flush = -1;
+			prebuffer = TRUE;
+		}
+
+	}
+
+#if 0
+	/* NBS has no reset */
+	ioctl(fd, SNDCTL_DSP_RESET, 0);
+#endif
+	nbs_delstream(nbs);
+	nbs = NULL;	
+	g_free(buffer);
+	pthread_exit(NULL);
+}
+
+void nbs_set_audio_params(void)
+{
+	int frag, stereo, ret;
+	struct timeval tv;
+	fd_set set;
+
+#if 0
+	/* None of this works with nbs */
+	ioctl(fd, SNDCTL_DSP_RESET, 0);
+	frag = (NFRAGS << 16) | fragsize;
+	ioctl(fd, SNDCTL_DSP_SETFRAGMENT, &frag);
+	ioctl(fd, SNDCTL_DSP_SETFMT, &output.format.nbs);
+	if (ioctl(fd, SNDCTL_DSP_SETFMT, &output.format.nbs) == -1)
+		g_warning("SNDCTL_DSP_SETFMT ioctl failed: %s",
+			  strerror(errno));
+#endif
+	/* Don't store in output.channels, but in another variable */
+	realchannels = 2;
+
+	nbs_convert_func =
+		nbs_get_convert_func(output.format.nbs,
+				     nbs_get_format(effect.format.xmms));
+
+	/*
+	 * Stupid hack to find out if the driver support selects, some
+	 * drivers won't work properly without a select and some won't
+	 * work with a select :/
+	 */
+	
+	tv.tv_sec = 0;
+	tv.tv_usec = 50000;
+	FD_ZERO(&set);
+	FD_SET(nbs_fd(nbs), &set);
+	ret = select(nbs_fd(nbs) + 1, NULL, &set, NULL, &tv);
+	if (ret > 0)
+		select_works = TRUE;
+	else
+		select_works = FALSE;
+}
+
+gint nbs_open(AFormat fmt, gint rate, gint nch)
+{
+	char host[256] = "dunno";
+	if (nbs_cfg.use_alt_audio_device && nbs_cfg.alt_audio_device)
+		device_name = g_strdup(nbs_cfg.alt_audio_device);
+	else
+	{
+		if (nbs_cfg.audio_device > 0)
+			device_name = g_strdup_printf("%s%d", DEV_DSP, nbs_cfg.audio_device);
+		else
+			device_name = g_strdup(DEV_DSP);
+	}
+	gethostname(host, sizeof(host));
+	nbs =  nbs_newstream("xmms", host, NBS_FLAG_OVERRIDE);
+	if (nbs == NULL)
+	{
+		g_warning("nbs_open(): Failed to open NBS stream: %s", strerror(errno));
+		g_free(device_name);
+		return 0;
+	}
+	nbs_setblocking(nbs, 1);
+	nbs_setdebug(nbs, 1);
+	nbs_setblocksize(nbs, blk_size);
+	if (nbs_connect(nbs))
+	{
+		g_warning("nbs_open(): Failed to connect NBS stream: %s", strerror(errno));
+		nbs_delstream(nbs);
+		g_free(device_name);
+		return 0;
+	}
+	
+	input.format.xmms = fmt;
+	input.frequency = rate;
+	input.channels = nch;
+	input.bps = nbs_calc_bitrate(nbs_get_format(fmt), rate, nch);
+
+	nbs_setup_format(fmt, rate, nch);
+	
+	realtime = xmms_check_realtime_priority();
+	
+	if(!realtime)
+	{
+		buffer_size = (nbs_cfg.buffer_size * input.bps) / 1000;
+		if (buffer_size < 8192)
+			buffer_size = 8192;
+		prebuffer_size = (buffer_size * nbs_cfg.prebuffer) / 100;
+		if (buffer_size - prebuffer_size < 4096)
+			prebuffer_size = buffer_size - 4096;
+
+		buffer_size += device_buffer_size;
+		buffer = g_malloc0(buffer_size);
+	}
+	flush = -1;
+	prebuffer = TRUE;
+	wr_index = rd_index = output_time_offset = written = output_bytes = 0;
+	paused = FALSE;
+	do_pause = FALSE;
+	unpause = FALSE;
+	remove_prebuffer = FALSE;
+
+	going = 1;
+	if (!realtime)
+		pthread_create(&buffer_thread, NULL, nbs_loop, NULL);
+	return 1;
+}
diff -uNr xmms-1.2.7/Output/nbs/configure.c xmms-1.2.7-nbsworking/Output/nbs/configure.c
--- xmms-1.2.7/Output/nbs/configure.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.7-nbsworking/Output/nbs/configure.c	2003-01-20 10:03:45.000000000 -0600
@@ -0,0 +1,323 @@
+/*  XMMS - Cross-platform multimedia player
+ *  Copyright (C) 1998-2001  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *  Copyright (C) 1999-2001  Håvard Kvålen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmms/i18n.h"
+#include "nbs.h"
+
+#if 0
+/* One day I'll be configurable... */
+static GtkWidget *configure_win = NULL;
+static GtkWidget *mixer_usemaster_check, *buffer_size_spin, *buffer_pre_spin;
+static GtkWidget *adevice_use_alt_check, *audio_alt_device_entry;
+static GtkWidget *mdevice_use_alt_check, *mixer_alt_device_entry;
+static gint audio_device, mixer_device;
+
+static void configure_win_ok_cb(GtkWidget * w, gpointer data)
+{
+	ConfigFile *cfgfile;
+
+	oss_cfg.audio_device = audio_device;
+	oss_cfg.mixer_device = mixer_device;
+	oss_cfg.buffer_size =
+		gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(buffer_size_spin));
+	oss_cfg.prebuffer =
+		gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(buffer_pre_spin));
+	oss_cfg.use_master =
+		gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(mixer_usemaster_check));
+	oss_cfg.use_alt_audio_device =
+		gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(adevice_use_alt_check));
+	oss_cfg.use_alt_mixer_device =
+		gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(mdevice_use_alt_check));
+	g_free(oss_cfg.alt_audio_device);
+	oss_cfg.alt_audio_device =
+		gtk_editable_get_chars(GTK_EDITABLE(audio_alt_device_entry), 0, -1);
+	g_strstrip(oss_cfg.alt_audio_device);
+	g_free(oss_cfg.alt_mixer_device);
+	oss_cfg.alt_mixer_device =
+		gtk_editable_get_chars(GTK_EDITABLE(mixer_alt_device_entry), 0, -1);
+	g_strstrip(oss_cfg.alt_mixer_device);
+
+	if (oss_cfg.use_alt_audio_device)
+		/* do a minimum of sanity checking */
+		if (oss_cfg.alt_audio_device[0] != '/') 
+			oss_cfg.use_alt_audio_device = FALSE;
+	if (oss_cfg.use_alt_mixer_device)
+		if (oss_cfg.alt_mixer_device[0] != '/') 
+			oss_cfg.use_alt_mixer_device = FALSE;
+	
+	cfgfile = xmms_cfg_open_default_file();
+
+	xmms_cfg_write_int(cfgfile, "OSS", "audio_device", oss_cfg.audio_device);
+	xmms_cfg_write_int(cfgfile, "OSS", "mixer_device", oss_cfg.mixer_device);
+	xmms_cfg_write_int(cfgfile, "OSS", "buffer_size", oss_cfg.buffer_size);
+	xmms_cfg_write_int(cfgfile, "OSS", "prebuffer", oss_cfg.prebuffer);
+	xmms_cfg_write_boolean(cfgfile,"OSS","use_master",oss_cfg.use_master);
+	xmms_cfg_write_boolean(cfgfile, "OSS", "use_alt_audio_device", oss_cfg.use_alt_audio_device);
+	xmms_cfg_write_string(cfgfile, "OSS", "alt_audio_device", oss_cfg.alt_audio_device);
+	xmms_cfg_write_boolean(cfgfile, "OSS", "use_alt_mixer_device", oss_cfg.use_alt_mixer_device);
+	xmms_cfg_write_string(cfgfile, "OSS", "alt_mixer_device", oss_cfg.alt_mixer_device);
+	xmms_cfg_write_default_file(cfgfile);
+	xmms_cfg_free(cfgfile);
+
+	gtk_widget_destroy(configure_win);
+}
+
+static void configure_win_audio_dev_cb(GtkWidget * widget, gint device)
+{
+	audio_device = device;
+}
+
+static void configure_win_mixer_dev_cb(GtkWidget * widget, gint device)
+{
+	mixer_device = device;
+}
+
+static void audio_device_toggled(GtkToggleButton * widget, gpointer data)
+{
+	gboolean use_alt_audio_device = gtk_toggle_button_get_active(widget);
+	gtk_widget_set_sensitive(GTK_WIDGET(data), !use_alt_audio_device);
+	gtk_widget_set_sensitive(audio_alt_device_entry, use_alt_audio_device);
+}
+
+static void mixer_device_toggled(GtkToggleButton * widget, gpointer data)
+{
+	gboolean use_alt_device = gtk_toggle_button_get_active(widget);
+	gtk_widget_set_sensitive(GTK_WIDGET(data), !use_alt_device);
+	gtk_widget_set_sensitive(mixer_alt_device_entry, use_alt_device);
+}
+
+static void scan_devices(gchar * type, GtkWidget * option_menu, GtkSignalFunc sigfunc)
+{
+	GtkWidget *menu, *item;
+	FILE *file;
+	gchar buffer[256], *temp, *tmp2;
+	gboolean found = FALSE;
+	gint index = 0;
+
+	menu = gtk_menu_new();
+
+	if ((file = fopen("/dev/sndstat", "r")))
+	{
+		while (fgets(buffer, 255, file))
+		{
+			if (found && buffer[0] == '\n')
+				break;
+			if (buffer[strlen(buffer) - 1] == '\n')
+				buffer[strlen(buffer) - 1] = '\0';
+			if (found)
+			{
+				if (index == 0)
+				{
+					tmp2 = strchr(buffer, ':');
+					if (tmp2)
+					{
+						tmp2++;
+						while (*tmp2 == ' ')
+							tmp2++;
+					}
+					else
+						tmp2 = buffer;
+					temp = g_strdup_printf(_("Default (%s)"), tmp2);
+					item = gtk_menu_item_new_with_label(temp);
+					g_free(temp);
+				}
+				else
+					item = gtk_menu_item_new_with_label(buffer);
+				gtk_signal_connect(GTK_OBJECT(item), "activate", sigfunc, (gpointer) index++);
+				gtk_widget_show(item);
+				gtk_menu_append(GTK_MENU(menu), item);
+			}
+			if (!strcasecmp(buffer, type))
+				found = 1;
+
+		}
+		fclose(file);
+	}
+	else
+	{
+		item = gtk_menu_item_new_with_label(_("Default"));
+		gtk_signal_connect(GTK_OBJECT(item), "activate", sigfunc, (gpointer) 0);
+		gtk_widget_show(item);
+		gtk_menu_append(GTK_MENU(menu), item);
+	}
+	gtk_option_menu_set_menu(GTK_OPTION_MENU(option_menu), menu);
+}
+
+void oss_configure(void)
+{
+	GtkWidget *vbox, *notebook;
+	GtkWidget *dev_vbox, *adevice_frame, *adevice_box, *adevice;
+	GtkWidget *mdevice_frame, *mdevice_box, *mdevice;
+	GtkWidget *buffer_frame, *buffer_vbox, *buffer_table;
+	GtkWidget *buffer_size_box, *buffer_size_label;
+	GtkObject *buffer_size_adj, *buffer_pre_adj;
+	GtkWidget *buffer_pre_box, *buffer_pre_label;
+	GtkWidget *audio_alt_box, *mixer_alt_box;
+	GtkWidget *bbox, *ok, *cancel;
+	GtkWidget *mixer_table, *mixer_frame;
+	
+	if (configure_win)
+	{
+		gdk_window_raise(configure_win->window);
+		return;
+	}
+
+	configure_win = gtk_window_new(GTK_WINDOW_DIALOG);
+	gtk_signal_connect(GTK_OBJECT(configure_win), "destroy", GTK_SIGNAL_FUNC(gtk_widget_destroyed), &configure_win);
+	gtk_window_set_title(GTK_WINDOW(configure_win), _("OSS Driver configuration"));
+	gtk_window_set_policy(GTK_WINDOW(configure_win), FALSE, FALSE, FALSE);
+	gtk_window_set_position(GTK_WINDOW(configure_win), GTK_WIN_POS_MOUSE);
+	gtk_container_border_width(GTK_CONTAINER(configure_win), 10);
+	
+	vbox = gtk_vbox_new(FALSE, 10);
+	gtk_container_add(GTK_CONTAINER(configure_win), vbox);
+	
+	notebook = gtk_notebook_new();
+	gtk_box_pack_start(GTK_BOX(vbox), notebook, TRUE, TRUE, 0);
+	
+	dev_vbox = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(dev_vbox), 5);
+
+	adevice_frame = gtk_frame_new(_("Audio device:"));
+	gtk_box_pack_start(GTK_BOX(dev_vbox), adevice_frame, FALSE, FALSE, 0);
+	
+	adevice_box = gtk_vbox_new(FALSE, 5);
+	gtk_container_set_border_width(GTK_CONTAINER(adevice_box), 5);
+	gtk_container_add(GTK_CONTAINER(adevice_frame), adevice_box);
+
+	adevice = gtk_option_menu_new();
+	gtk_box_pack_start(GTK_BOX(adevice_box), adevice, TRUE, TRUE, 0);
+#if defined(HAVE_NEWPCM)
+	scan_devices("Installed devices:",adevice, configure_win_audio_dev_cb);
+#else
+	scan_devices("Audio devices:", adevice, configure_win_audio_dev_cb);
+#endif
+	audio_device = oss_cfg.audio_device;
+	gtk_option_menu_set_history(GTK_OPTION_MENU(adevice), oss_cfg.audio_device);
+	audio_alt_box = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start_defaults(GTK_BOX(adevice_box), audio_alt_box);
+	adevice_use_alt_check = gtk_check_button_new_with_label(_("Use alternate device:"));
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(adevice_use_alt_check), oss_cfg.use_alt_audio_device);
+	gtk_signal_connect(GTK_OBJECT(adevice_use_alt_check), "toggled", audio_device_toggled, adevice);
+	gtk_box_pack_start(GTK_BOX(audio_alt_box), adevice_use_alt_check, FALSE, FALSE, 0);
+	audio_alt_device_entry = gtk_entry_new();
+	if (oss_cfg.alt_audio_device != NULL)
+		gtk_entry_set_text(GTK_ENTRY(audio_alt_device_entry), oss_cfg.alt_audio_device);
+	else
+		gtk_entry_set_text(GTK_ENTRY(audio_alt_device_entry), DEV_DSP);
+	gtk_box_pack_start_defaults(GTK_BOX(audio_alt_box), audio_alt_device_entry);
+
+	if (oss_cfg.use_alt_audio_device)
+		gtk_widget_set_sensitive(adevice, FALSE);
+	else
+		gtk_widget_set_sensitive(audio_alt_device_entry, FALSE);
+
+	mdevice_frame = gtk_frame_new(_("Mixer device:"));
+	gtk_box_pack_start(GTK_BOX(dev_vbox), mdevice_frame, FALSE, FALSE, 0);
+	
+	mdevice_box = gtk_vbox_new(FALSE, 0);
+	gtk_container_set_border_width(GTK_CONTAINER(mdevice_box), 5);
+	gtk_container_add(GTK_CONTAINER(mdevice_frame), mdevice_box);
+
+	mdevice = gtk_option_menu_new();
+	gtk_box_pack_start(GTK_BOX(mdevice_box), mdevice, TRUE, TRUE, 0);
+#if defined(HAVE_NEWPCM)
+	scan_devices("Installed devices:",mdevice, configure_win_mixer_dev_cb);
+#else
+	scan_devices("Mixers:", mdevice, configure_win_mixer_dev_cb);
+#endif
+	mixer_device = oss_cfg.mixer_device;
+	gtk_option_menu_set_history(GTK_OPTION_MENU(mdevice), oss_cfg.mixer_device);
+	mixer_alt_box = gtk_hbox_new(FALSE, 0);
+	gtk_box_pack_start_defaults(GTK_BOX(mdevice_box), mixer_alt_box);
+	mdevice_use_alt_check = gtk_check_button_new_with_label(_("Use alternate device:"));
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(mdevice_use_alt_check), oss_cfg.use_alt_mixer_device);
+	gtk_signal_connect(GTK_OBJECT(mdevice_use_alt_check), "toggled", mixer_device_toggled, mdevice);
+	gtk_box_pack_start(GTK_BOX(mixer_alt_box), mdevice_use_alt_check, FALSE, FALSE, 0);
+	mixer_alt_device_entry = gtk_entry_new();
+	if (oss_cfg.alt_mixer_device != NULL)
+		gtk_entry_set_text(GTK_ENTRY(mixer_alt_device_entry), oss_cfg.alt_mixer_device);
+	else
+		gtk_entry_set_text(GTK_ENTRY(mixer_alt_device_entry), DEV_MIXER);
+	gtk_box_pack_start_defaults(GTK_BOX(mixer_alt_box), mixer_alt_device_entry);
+
+	if (oss_cfg.use_alt_mixer_device)
+		gtk_widget_set_sensitive(mdevice, FALSE);
+	else
+		gtk_widget_set_sensitive(mixer_alt_device_entry, FALSE);
+
+	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), dev_vbox, gtk_label_new(_("Devices")));
+
+	buffer_frame = gtk_frame_new(_("Buffering:"));
+	gtk_container_set_border_width(GTK_CONTAINER(buffer_frame), 5);
+
+	buffer_vbox = gtk_vbox_new(FALSE, 0);
+	gtk_container_add(GTK_CONTAINER(buffer_frame), buffer_vbox);
+
+	buffer_table = gtk_table_new(2, 1, TRUE);
+	gtk_container_set_border_width(GTK_CONTAINER(buffer_table), 5);
+	gtk_box_pack_start(GTK_BOX(buffer_vbox), buffer_table, FALSE, FALSE, 0);
+
+	buffer_size_box = gtk_hbox_new(FALSE, 5);
+	gtk_table_attach_defaults(GTK_TABLE(buffer_table), buffer_size_box, 0, 1, 0, 1);
+	buffer_size_label = gtk_label_new(_("Buffer size (ms):"));
+	gtk_box_pack_start(GTK_BOX(buffer_size_box), buffer_size_label, FALSE, FALSE, 0);
+	buffer_size_adj = gtk_adjustment_new(oss_cfg.buffer_size, 200, 10000, 100, 100, 100);
+	buffer_size_spin = gtk_spin_button_new(GTK_ADJUSTMENT(buffer_size_adj), 8, 0);
+	gtk_widget_set_usize(buffer_size_spin, 60, -1);
+	gtk_box_pack_start(GTK_BOX(buffer_size_box), buffer_size_spin, FALSE, FALSE, 0);
+
+	buffer_pre_box = gtk_hbox_new(FALSE, 5);
+	gtk_table_attach_defaults(GTK_TABLE(buffer_table), buffer_pre_box, 1, 2, 0, 1);
+	buffer_pre_label = gtk_label_new(_("Pre-buffer (percent):"));
+	gtk_box_pack_start(GTK_BOX(buffer_pre_box), buffer_pre_label, FALSE, FALSE, 0);
+	buffer_pre_adj = gtk_adjustment_new(oss_cfg.prebuffer, 0, 90, 1, 1, 1);
+	buffer_pre_spin = gtk_spin_button_new(GTK_ADJUSTMENT(buffer_pre_adj), 1, 0);
+	gtk_widget_set_usize(buffer_pre_spin, 60, -1);
+	gtk_box_pack_start(GTK_BOX(buffer_pre_box), buffer_pre_spin, FALSE, FALSE, 0);
+
+	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), buffer_frame, gtk_label_new(_("Buffering")));
+	mixer_frame = gtk_frame_new(_("Mixer Settings:"));
+	gtk_container_set_border_width(GTK_CONTAINER(mixer_frame), 5);
+	mixer_table = gtk_table_new(3, 2, TRUE);
+	gtk_container_add(GTK_CONTAINER(mixer_frame), mixer_table);
+	gtk_container_set_border_width(GTK_CONTAINER(mixer_table), 5);
+	mixer_usemaster_check=gtk_check_button_new_with_label(_("Volume controls Master not PCM"));
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(mixer_usemaster_check),oss_cfg.use_master);
+	gtk_table_attach_defaults(GTK_TABLE(mixer_table), mixer_usemaster_check, 0, 1, 0, 1);
+	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), mixer_frame, gtk_label_new(_("Mixer")));
+
+	bbox = gtk_hbutton_box_new();
+	gtk_button_box_set_layout(GTK_BUTTON_BOX(bbox), GTK_BUTTONBOX_END);
+	gtk_button_box_set_spacing(GTK_BUTTON_BOX(bbox), 5);
+	gtk_box_pack_start(GTK_BOX(vbox), bbox, FALSE, FALSE, 0);
+
+	ok = gtk_button_new_with_label(_("Ok"));
+	gtk_signal_connect(GTK_OBJECT(ok), "clicked", GTK_SIGNAL_FUNC(configure_win_ok_cb), NULL);
+	GTK_WIDGET_SET_FLAGS(ok, GTK_CAN_DEFAULT);
+	gtk_box_pack_start(GTK_BOX(bbox), ok, TRUE, TRUE, 0);
+	gtk_widget_grab_default(ok);
+
+	cancel = gtk_button_new_with_label(_("Cancel"));
+	gtk_signal_connect_object(GTK_OBJECT(cancel), "clicked", GTK_SIGNAL_FUNC(gtk_widget_destroy), GTK_OBJECT(configure_win));
+	GTK_WIDGET_SET_FLAGS(cancel, GTK_CAN_DEFAULT);
+	gtk_box_pack_start(GTK_BOX(bbox), cancel, TRUE, TRUE, 0);
+
+	gtk_widget_show_all(configure_win);
+}
+#endif
diff -uNr xmms-1.2.7/Output/nbs/convert.c xmms-1.2.7-nbsworking/Output/nbs/convert.c
--- xmms-1.2.7/Output/nbs/convert.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.7-nbsworking/Output/nbs/convert.c	2003-01-20 13:08:16.000000000 -0600
@@ -0,0 +1,287 @@
+/*
+ *  Copyright (C) 2001  Haavard Kvaalen
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "xmmsnbs.h"
+#include <nbs.h>
+
+void* nbs_get_convert_buffer(size_t size)
+{
+	static size_t length;
+	static void *buffer;
+
+	if (size > 0 && size <= length)
+		return buffer;
+
+	length = size;
+	buffer = g_realloc(buffer, size);
+	return buffer;
+}
+
+static int convert_swap_endian(void **data, int length)
+{
+	guint16 *ptr = *data;
+	int i;
+	for (i = 0; i < length; i += 2, ptr++)
+		*ptr = GUINT16_SWAP_LE_BE(*ptr);
+
+	return i;
+}
+
+static int convert_swap_sign_and_endian_to_native(void **data, int length)
+{
+	guint16 *ptr = *data;
+	int i;
+	for (i = 0; i < length; i += 2, ptr++)
+		*ptr = GUINT16_SWAP_LE_BE(*ptr) ^ 1 << 15;
+
+	return i;
+}
+
+static int convert_swap_sign_and_endian_to_alien(void **data, int length)
+{
+	guint16 *ptr = *data;
+	int i;
+	for (i = 0; i < length; i += 2, ptr++)
+		*ptr = GUINT16_SWAP_LE_BE(*ptr ^ 1 << 15);
+
+	return i;
+}
+
+static int convert_swap_sign16(void **data, int length)
+{
+	gint16 *ptr = *data;
+	int i;
+	for (i = 0; i < length; i += 2, ptr++)
+		*ptr ^= 1 << 15;
+
+	return i;
+}
+
+static int convert_swap_sign8(void **data, int length)
+{
+	gint8 *ptr = *data;
+	int i;
+	for (i = 0; i < length; i++)
+		*ptr++ ^= 1 << 7;
+
+	return i;
+}
+
+static int convert_to_8_native_endian(void **data, int length)
+{
+	gint8 *output = *data;
+	gint16 *input = *data;
+	int i;
+	for (i = 0; i < length / 2; i++)
+		*output++ = *input++ >> 8;
+
+	return i;
+}
+
+static int convert_to_8_native_endian_swap_sign(void **data, int length)
+{
+	gint8 *output = *data;
+	gint16 *input = *data;
+	int i;
+	for (i = 0; i < length / 2; i++)
+		*output++ = (*input++ >> 8) ^ (1 << 7);
+
+	return i;
+}
+
+
+static int convert_to_8_alien_endian(void **data, int length)
+{
+	gint8 *output = *data;
+	gint16 *input = *data;
+	int i;
+	for (i = 0; i < length / 2; i++)
+		*output++ = *input++ & 0xff;
+
+	return i;
+}
+
+static int convert_to_8_alien_endian_swap_sign(void **data, int length)
+{
+	gint8 *output = *data;
+	gint16 *input = *data;
+	int i;
+	for (i = 0; i < length / 2; i++)
+		*output++ = (*input++ & 0xff) ^ (1 << 7);
+
+	return i;
+}
+
+static int convert_to_16_native_endian(void **data, int length)
+{
+	guint8 *input = *data;
+	guint16 *output;
+	int i;
+	*data = nbs_get_convert_buffer(length * 2);
+	output = *data;
+	for (i = 0; i < length; i++)
+		*output++ = *input++ << 8;
+
+	return i * 2;
+}
+
+static int convert_to_16_native_endian_swap_sign(void **data, int length)
+{
+	guint8 *input = *data;
+	guint16 *output;
+	int i;
+	*data = nbs_get_convert_buffer(length * 2);
+	output = *data;
+	for (i = 0; i < length; i++)
+		*output++ = (*input++ << 8) ^ (1 << 15);
+
+	return i * 2;
+}
+
+
+static int convert_to_16_alien_endian(void **data, int length)
+{
+	guint8 *input = *data;
+	guint16 *output;
+	int i;
+	*data = nbs_get_convert_buffer(length * 2);
+	output = *data;
+	for (i = 0; i < length; i++)
+		*output++ = *input++;
+
+	return i * 2;
+}
+
+static int convert_to_16_alien_endian_swap_sign(void **data, int length)
+{
+	guint8 *input = *data;
+	guint16 *output;
+	int i;
+	*data = nbs_get_convert_buffer(length * 2);
+	output = *data;
+	for (i = 0; i < length; i++)
+		*output++ = *input++ ^ (1 << 7);
+
+	return i * 2;
+}
+
+int (*nbs_get_convert_func(int output, int input))(void **, int)
+{
+	if (output == input)
+		return NULL;
+
+	if ((output == NBS_FMT_U16_BE && input == NBS_FMT_U16_LE) ||
+	    (output == NBS_FMT_U16_LE && input == NBS_FMT_U16_BE) ||
+	    (output == NBS_FMT_S16_BE && input == NBS_FMT_S16_LE) ||
+	    (output == NBS_FMT_S16_LE && input == NBS_FMT_S16_BE))
+		return convert_swap_endian;
+
+	if ((output == NBS_FMT_U16_BE && input == NBS_FMT_S16_BE) ||
+	    (output == NBS_FMT_U16_LE && input == NBS_FMT_S16_LE) ||
+	    (output == NBS_FMT_S16_BE && input == NBS_FMT_U16_BE) ||
+	    (output == NBS_FMT_S16_LE && input == NBS_FMT_U16_LE))
+		return convert_swap_sign16;
+
+	if ((IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_S16_LE) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_U16_LE))) ||
+	    (!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_S16_BE) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_U16_BE))))
+		return convert_swap_sign_and_endian_to_native;
+		
+	if ((!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_S16_LE) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_U16_LE))) ||
+	    (IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_S16_BE) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_U16_BE))))
+		return convert_swap_sign_and_endian_to_alien;
+
+	if ((IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_U16_BE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_S16_BE))) ||
+	    (!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_U16_LE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_S16_LE))))
+		return convert_to_8_native_endian;
+
+	if ((IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_S16_BE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_U16_BE))) ||
+	    (!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_S16_LE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_U16_LE))))
+		return convert_to_8_native_endian_swap_sign;
+
+	if ((!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_U16_BE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_S16_BE))) ||
+	    (IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_U16_LE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_S16_LE))))
+		return convert_to_8_alien_endian;
+
+	if ((!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_S16_BE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_U16_BE))) ||
+	    (IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U8 && input == NBS_FMT_S16_LE) ||
+	      (output == NBS_FMT_S8 && input == NBS_FMT_U16_LE))))
+		return convert_to_8_alien_endian_swap_sign;
+
+	if ((output == NBS_FMT_U8 && input == NBS_FMT_S8) ||
+	    (output == NBS_FMT_S8 && input == NBS_FMT_U8))
+		return convert_swap_sign8;
+
+	if ((IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_U8) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_S8))) ||
+	    (!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_U8) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_S8))))
+		return convert_to_16_native_endian;
+
+	if ((IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_S8) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_U8))) ||
+	    (!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_S8) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_U8))))
+		return convert_to_16_native_endian_swap_sign;
+
+	if ((!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_U8) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_S8))) ||
+	    (IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_U8) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_S8))))
+		return convert_to_16_alien_endian;
+
+	if ((!IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_BE && input == NBS_FMT_S8) ||
+	      (output == NBS_FMT_S16_BE && input == NBS_FMT_U8))) ||
+	    (IS_BIG_ENDIAN &&
+	     ((output == NBS_FMT_U16_LE && input == NBS_FMT_S8) ||
+	      (output == NBS_FMT_S16_LE && input == NBS_FMT_U8))))
+		return convert_to_16_alien_endian_swap_sign;
+
+	g_warning("Translation needed, but not available.\n"
+		  "Input: %d; Output %d.", input, output);
+	return NULL;
+}
diff -uNr xmms-1.2.7/Output/nbs/init.c xmms-1.2.7-nbsworking/Output/nbs/init.c
--- xmms-1.2.7/Output/nbs/init.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.7-nbsworking/Output/nbs/init.c	2003-01-20 13:11:37.000000000 -0600
@@ -0,0 +1,50 @@
+/*  XMMS - Crnbs-platform multimedia player
+ *  Copyright (C) 1998-2000  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmmsnbs.h"
+#include "libxmms/configfile.h"
+
+NBSConfig nbs_cfg;
+
+void nbs_init(void)
+{
+	ConfigFile *cfgfile;
+
+	memset(&nbs_cfg, 0, sizeof (NBSConfig));
+
+	nbs_cfg.audio_device = 0;
+	nbs_cfg.mixer_device = 0;
+	nbs_cfg.buffer_size = 3000;
+	nbs_cfg.prebuffer = 25;
+	nbs_cfg.use_alt_audio_device = FALSE;
+	nbs_cfg.alt_audio_device = NULL;
+	nbs_cfg.use_master=0;
+	
+	if ((cfgfile = xmms_cfg_open_default_file()))
+	{
+		xmms_cfg_read_int(cfgfile, "NBS", "audio_device", &nbs_cfg.audio_device);
+		xmms_cfg_read_int(cfgfile, "NBS", "mixer_device", &nbs_cfg.mixer_device);
+		xmms_cfg_read_int(cfgfile, "NBS", "buffer_size", &nbs_cfg.buffer_size);
+		xmms_cfg_read_int(cfgfile, "NBS", "prebuffer", &nbs_cfg.prebuffer);
+		xmms_cfg_read_boolean(cfgfile, "NBS", "use_master", &nbs_cfg.use_master);
+		xmms_cfg_read_boolean(cfgfile, "NBS", "use_alt_audio_device", &nbs_cfg.use_alt_audio_device);
+		xmms_cfg_read_string(cfgfile, "NBS", "alt_audio_device", &nbs_cfg.alt_audio_device);
+		xmms_cfg_read_boolean(cfgfile, "NBS", "use_alt_mixer_device", &nbs_cfg.use_alt_mixer_device);
+		xmms_cfg_read_string(cfgfile, "NBS", "alt_mixer_device", &nbs_cfg.alt_mixer_device);
+		xmms_cfg_free(cfgfile);
+	}
+}
diff -uNr xmms-1.2.7/Output/nbs/Makefile.am xmms-1.2.7-nbsworking/Output/nbs/Makefile.am
--- xmms-1.2.7/Output/nbs/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.7-nbsworking/Output/nbs/Makefile.am	2003-01-20 09:56:47.000000000 -0600
@@ -0,0 +1,26 @@
+if HAVE_OSS
+
+nbsltlibs = libNBS.la
+nbssources = nbs.c nbs.h \
+mixer.c \
+about.c \
+configure.c \
+audio.c \
+init.c \
+convert.c
+
+else
+
+nbsltlibs =
+nbssources =
+
+endif
+
+lib_LTLIBRARIES = $(nbsltlibs)
+
+libdir = $(plugindir)/$(OUTPUT_PLUGIN_DIR)
+
+libNBS_la_LDFLAGS = @PLUGIN_LDFLAGS@
+libNBS_la_LIBADD = @GTK_LIBS@ @PTHREAD_LIBS@ -lnbs
+libNBS_la_SOURCES= $(nbssources)
+INCLUDES = @GTK_CFLAGS@ @OSS_CFLAGS@ -I$(top_builddir)/intl
diff -uNr xmms-1.2.7/Output/nbs/mixer.c xmms-1.2.7-nbsworking/Output/nbs/mixer.c
--- xmms-1.2.7/Output/nbs/mixer.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.7-nbsworking/Output/nbs/mixer.c	2003-01-20 10:01:58.000000000 -0600
@@ -0,0 +1,98 @@
+/*  XMMS - Cross-platform multimedia player
+ *  Copyright (C) 1998-2000  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "nbs.h"
+#include <errno.h>
+
+#if 0
+/* One day I'll have an NBS Mixer and it will go here.... */
+static char* get_mixer_device(void)
+{
+	char *name;
+	
+	if (oss_cfg.use_alt_mixer_device && oss_cfg.alt_mixer_device)
+		name = g_strdup(oss_cfg.alt_mixer_device);
+	else if (oss_cfg.mixer_device > 0)
+		name = g_strdup_printf("%s%d", DEV_MIXER, oss_cfg.mixer_device);
+	else
+		name = g_strdup(DEV_MIXER);
+
+	return name;
+}
+
+void oss_get_volume(int *l, int *r)
+{
+	int fd, v, cmd, devs;
+	gchar *devname;
+
+	devname = get_mixer_device();
+	fd = open(devname, O_RDONLY);
+	g_free(devname);
+
+	/*
+	 * We dont show any errors if this fails, as this is called
+	 * rather often
+	 */
+	if (fd != -1)
+	{
+		ioctl(fd, SOUND_MIXER_READ_DEVMASK, &devs);
+		if ((devs & SOUND_MASK_PCM) && (oss_cfg.use_master==0))
+			cmd = SOUND_MIXER_READ_PCM;
+		else if ((devs & SOUND_MASK_VOLUME) && (oss_cfg.use_master==1))
+			cmd = SOUND_MIXER_READ_VOLUME;
+		else
+		{
+			close(fd);
+			return;
+		}
+		ioctl(fd, cmd, &v);
+		*r = (v & 0xFF00) >> 8;
+		*l = (v & 0x00FF);
+		close(fd);
+	}
+}
+
+void oss_set_volume(int l, int r)
+{
+	int fd, v, cmd, devs;
+	gchar *devname;
+
+	devname = get_mixer_device();
+	fd = open(devname, O_RDONLY);
+
+	if (fd != -1)
+	{
+		ioctl(fd, SOUND_MIXER_READ_DEVMASK, &devs);
+		if ((devs & SOUND_MASK_PCM) && (oss_cfg.use_master==0))
+			cmd = SOUND_MIXER_WRITE_PCM;
+		else if ((devs & SOUND_MASK_VOLUME) && (oss_cfg.use_master==1))
+			cmd = SOUND_MIXER_WRITE_VOLUME;
+		else
+		{
+			close(fd);
+			return;
+		}
+		v = (r << 8) | l;
+		ioctl(fd, cmd, &v);
+		close(fd);
+	}
+	else
+		g_warning("oss_set_volume(): Failed to open mixer device (%s): %s",
+			  devname, strerror(errno));
+	g_free(devname);
+}
+#endif
diff -uNr xmms-1.2.7/Output/nbs/nbs.c xmms-1.2.7-nbsworking/Output/nbs/nbs.c
--- xmms-1.2.7/Output/nbs/nbs.c	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.7-nbsworking/Output/nbs/nbs.c	2003-01-20 23:37:31.000000000 -0600
@@ -0,0 +1,48 @@
+/*  XMMS - Crnbs-platform multimedia player
+ *  Copyright (C) 1998-2000  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *
+ *  Modified by Mark Spencer <markster@digium.com> to support NBS
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmmsnbs.h"
+#include "xmms/i18n.h"
+
+OutputPlugin nbs_op =
+{
+	NULL,
+	NULL,
+	NULL, /* Description */
+	NULL, /* nbs_init, */
+	nbs_about,
+	NULL, /* nbs_configure, */
+	NULL, /* nbs_get_volume, */
+	NULL, /* nbs_set_volume, */
+	nbs_open,
+	nbs_xwrite,
+	nbs_close,
+	nbs_flush,
+	nbs_pause,
+	nbs_free,
+	nbs_playing,
+	nbs_get_output_time,
+	nbs_get_written_time,
+};
+
+OutputPlugin *get_oplugin_info(void)
+{
+	nbs_op.description = g_strdup_printf(_("NBS Driver %s"), VERSION);
+	return &nbs_op;
+}
diff -uNr xmms-1.2.7/Output/nbs/xmmsnbs.h xmms-1.2.7-nbsworking/Output/nbs/xmmsnbs.h
--- xmms-1.2.7/Output/nbs/xmmsnbs.h	1969-12-31 18:00:00.000000000 -0600
+++ xmms-1.2.7-nbsworking/Output/nbs/xmmsnbs.h	2003-01-20 12:47:35.000000000 -0600
@@ -0,0 +1,85 @@
+/*  XMMS - Crnbs-platform multimedia player
+ *  Copyright (C) 1998-2000  Peter Alm, Mikael Alm, Olle Hallnas, Thomas Nilsson and 4Front Technologies
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef _XMMS_NBS_H
+#define _XMMS_NBS_H
+
+#include "config.h"
+
+#include <gtk/gtk.h>
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <nbs.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "xmms/plugin.h"
+#include "libxmms/configfile.h"
+
+#ifdef WORDS_BIGENDIAN
+# define IS_BIG_ENDIAN TRUE
+#else
+# define IS_BIG_ENDIAN FALSE
+#endif
+
+extern OutputPlugin op;
+
+typedef struct
+{
+	gint audio_device;
+	gint mixer_device;
+	gint buffer_size;
+	gint prebuffer;
+	gboolean use_master;
+	gboolean use_alt_audio_device, use_alt_mixer_device;
+	gchar *alt_audio_device, *alt_mixer_device;
+}
+NBSConfig;
+
+extern NBSConfig nbs_cfg;
+
+void nbs_init(void);
+void nbs_about(void);
+void nbs_configure(void);
+
+void nbs_get_volume(int *l, int *r);
+void nbs_set_volume(int l, int r);
+
+int nbs_playing(void);
+int nbs_free(void);
+void nbs_xwrite(void *ptr, int length);
+void nbs_close(void);
+void nbs_flush(int time);
+void nbs_pause(short p);
+int nbs_open(AFormat fmt, int rate, int nch);
+int nbs_get_output_time(void);
+int nbs_get_written_time(void);
+void nbs_set_audio_params(void);
+
+void* nbs_get_convert_buffer(size_t size);
+int (*nbs_get_convert_func(int output, int input))(void **, int);
+
+#endif
